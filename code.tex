\documentclass[a4paper,landscape]{report}
\usepackage[margin=0.5cm]{geometry}
\usepackage{listings}
\usepackage[usenames, dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{underscore}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}


\lstset{
    language=Python,
    basicstyle=\ttm,
    otherkeywords={self},             % Add keywords here
    keywordstyle=\ttb\color{deepblue},
    emph={MyClass,__init__},          % Custom highlighting
    emphstyle=\ttb\color{deepred},    % Custom highlighting style
    stringstyle=\color{deepgreen},
    frame=tb,                         % Any extra options here
    showstringspaces=false            %
    columns=fullflexible,
    frame=single,
    breaklines=true,
    linewidth = 28.5cm,
    commentstyle=\ttb\color{olive},
}



\begin{document}
\tableofcontents{}
\chapter{Chapter01}
\section{String Capwords}
\begin{lstlisting}[language=Python]
"""
Listing 1.1

The function capwords() capitalizes all of the words in a string
"""
import string


def main():
    s = "The quick brown fox jumped over the lazy dog."
    print(s)
    print(string.capwords(s))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Template}
\begin{lstlisting}[language=Python]
"""
Listing 1.2

String templates are intended as an alternative to the built-in
interpolation syntax. With string.Template interpolation, variables are
identified by prefixing the name with $ (e.g. $var).

Alternatively, if necessary to set them off from surrounding text, they
can be wrapped with curly braces (e.g. ${var})
"""
import string


def main():
    values = {"var": "foo"}

    t = string.Template("""
    Variable            : $var
    Escape              : $$
    Variable in text    : ${var}iable
    """)

    print("Template: ", t.substitute(values))

    s = """
    Variable            : %(var)s
    Escape              : %%
    Variable in text    : %(var)siable
    """

    print("INTERPOLATION: ", s % values)

    s = """
    Variable            : {var}
    Escape              : {{}}
    Variable in text    : {var}iable
    """

    print("FORMAT: ", s.format(**values))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Template Missing}
\begin{lstlisting}[language=Python]
"""
Listing 1.3

One key difference between templates and string interpolation or formatting
is that the type of the arguments is not taken into account. The values
are converted to strings, and the strings are inserted into the result.
No formatting options are available e.g. digits of floating-point value

safe_substitute() makes it possible to avoid exceptions if not all the
values needed by the template are provided as arguments
"""
import string


def main():
    values = {"var": "foo"}

    t = string.Template("$var is here but $missing is not provided")

    try:
        print("substitute(): ", t.substitute(values))
    except KeyError as err:
        print("ERROR: ", str(err))

    print("safe_substitute(): ", t.safe_substitute(values))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Template Advanced}
\begin{lstlisting}[language=Python]
"""
Listing 1.4

The default syntax for string.Template can be changed by adjusting the
regular expression patterns it uses to find the variable names in the
template body. A simple way to do that is to change the delimiter and
idpattern class attributes
"""
import string


class MyTemplate(string.Template):
    delimiter = "%"
    idpattern = "[a-z]+_[a-z]+"


def main():
    template_text = """
        Delimiter   : %%
        Replaced    : %with_underscore
        Ignored     : %notunderscored
    """

    d = {
        "with_underscore": "replaced",
        "notunderscored": "not replaced"
    }

    t = MyTemplate(template_text)
    print("Modified ID pattern: ")
    print(t.safe_substitute(d))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Template Defaultpattern}
\begin{lstlisting}[language=Python]
"""
Listing 1.5

For even more complex changes, it is possible to override the pattern
attribute and define an entirely new regular expression. The pattern
provided must contain four named groups for capturing the escaped
delimiter, the name variable, a braced version of the variable name,
and invalid delimiter patterns
"""
import string


def main():
    t = string.Template("$var")
    print(t.pattern.pattern)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Template Newsyntax}
\begin{lstlisting}[language=Python]
"""
Listing 1.6

This example defines a new patterns to create a new type of template,
using {{var}} as the variable syntax
"""
import re
import string


class MyTemplate(string.Template):
    delimiter = "{{"
    pattern = r"""
    \{\{(?:
    (?P<escaped>\{\{) |
    (?P<named>[_a-z][_a-z0-9]*)\}\} |
    (?P<braced>[a-z][_a-z09]*)\}\} |
    (?P<invalid>)
    )
    """


def main():
    t = MyTemplate("""
    {{{{
    {{var}}
    """)

    print("MATCHES: ", t.pattern.findall(t.template))
    print("SUBSTITUTED: ", t.safe_substitute(var="replacement"))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{String Constants}
\begin{lstlisting}[language=Python]
"""
Listing 1.7

The Formatter class implements the same layout specification language
as the format() method of str. Its features include
    type coercion
    alignment
    attribute and field references
    named and positional template arguments
    type-specific formatting options

Most of the time format() is more convenient, but Formatter is provided
as a way to build subclasses, for cases where variations are needed

The string module includes a number of constants related to ASCII
and numerical character sets
"""
import inspect
import string


def is_str(value):
    return isinstance(value, str)


def main():
    for name, value in inspect.getmembers(string, is_str):
        if name.startswith("_"):
            continue
        print(f"{name} = {value}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Fill}
\begin{lstlisting}[language=Python]
"""
Listing 1.9

The fill function takes text as input and produces formatted text
as output
"""
import textwrap
from textwrap_example import sample_text


def main():
    print(textwrap.fill(sample_text, width=50))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Dedent}
\begin{lstlisting}[language=Python]
"""
Listing 1.10

Use dedent() to produce better results and allow for the use of docstrings
or embedded multiline strings straight from Python code while removing
the formatting of the code itself.

If one line is already indented more than another, some whitespace will
not be removed (only common whitespace from each line is removed)

_Line_One
___Line_two
_Line_three

becomes
Line_One
__Line_two
Line_three
"""
import textwrap
from textwrap_example import sample_text


def main():
    dedented_text = textwrap.dedent(sample_text)
    print("Original:")
    print(sample_text)
    print("Dedented:")
    print(dedented_text)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Fill Width}
\begin{lstlisting}[language=Python]
"""
Listing 1.11

Dedented text can be passed through fill with a few different
width values.
"""
import textwrap
from textwrap_example import sample_text


def main():
    dedented_text = textwrap.dedent(sample_text).strip()
    for width in [45, 60]:
        print("{} Columns:\n".format(width))
        print(textwrap.fill(dedented_text, width=width))
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Indent}
\begin{lstlisting}[language=Python]
"""
Listing 1.12

Use the indent() function to add consistent prefix text to all of the
lines in a string.
"""
import textwrap
from textwrap_example import sample_text


def main():
    dedented_text = textwrap.dedent(sample_text)
    wrapped = textwrap.fill(dedented_text, width=50)
    wrapped += "\n\nSecond paragraph after a blank line"
    final = textwrap.indent(wrapped, "> ")

    print("Quoted block:\n")
    print(final)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Indent Predicate}
\begin{lstlisting}[language=Python]
"""
Listing 1.13

To control which lines receive the new prefix, pass a callable as the
predicate argument to indent. The callable will be invoked for each
line of text in turn, and the prefix will be added for lines where the
return value is true
"""
import textwrap
from textwrap_example import sample_text


def should_indent(line):
    print("Indent {!r}?".format(line))
    return len(line.strip()) % 2 == 0


def main():
    dedented_text = textwrap.dedent(sample_text)
    wrapped = textwrap.fill(dedented_text, width=50)
    final = textwrap.indent(wrapped, "EVEN ", predicate=should_indent)
    print("\nQuoted block:\n")
    print(final)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Hanging Indent}
\begin{lstlisting}[language=Python]
"""
Listing 1.14

In the same way that it is possible to set the width of the output,
the indent of the first line can be controlled independently of subsequent
lines

The indent values can include non-whitespace characters too. The
hanging indent can be prefixed with * to produce bullet points, for
example
"""
import textwrap
from textwrap_example import sample_text


def main():
    dedented_text = textwrap.dedent(sample_text).strip()
    print(textwrap.fill(dedented_text,
                        initial_indent="",
                        subsequent_indent=" " * 4,
                        width=50))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Shorten}
\begin{lstlisting}[language=Python]
"""
Listing 1.15

To truncate text to create a summary or preview, use shorten(). All
existing whitespace, such as tabs, newlines and series of multiple
spaces, will be standardized to a single space. Then the text
will be truncated to a length less than or equal to what is requested,
between word boundaries so that no partial words are included

If non-whitespace text is removed from the original text as part of the
truncation, it is replaced with a placeholder value [...] by default.
Default can be changed by supplying placeholder argument to shorten()
"""
import textwrap
from textwrap_example import sample_text


def main():
    dedented_text = textwrap.dedent(sample_text)
    original = textwrap.fill(dedented_text, width=50)

    print("Original:\n")
    print(original)

    shortened = textwrap.shorten(original, 100)
    shortened_wrapped = textwrap.fill(shortened, width=50)

    print("\nShortened:\n")
    print(shortened_wrapped)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Simple Match}
\begin{lstlisting}[language=Python]
"""
Listing 1.16

Regular expressions are text matching patterns described with a formal
syntax. The patterns are interpreted as a set of instructions, which are
then executed with a string as input to produce a matching subset or
modified version of the original.

The most common use for re is to search for patterns in text. The search()
function takes the pattern and text to scan, and returns a Match object
when the pattern is found. If the pattern is not found, search() returns
None.

Each match object holds information about the nature of the match,
including the original input string, the regular expression used, and
the location within the original string where the pattern occurs

The start() and end() methods give the indexes into the string showing
where the text matched by the pattern occurs.
"""
import re


def main():
    pattern = "this"
    text = "Does this text match the pattern?"
    match = re.search(pattern, text)

    s = match.start()
    e = match.end()

    print(f"Found '{match.re.pattern}'\n in '{match.string}'\n from"
          f" {s} to {e} ('{text[s:e]}')")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Simple Compiled}
\begin{lstlisting}[language=Python]
"""
Listing 1.17

Although re includes module-level functions for working with regular
expressions as text strings, it is more efficient to compile the
expressions a program uses frequently. The compile() function converts
and expression string into a RegexObject

The module-level functions maintain a cache of compiled expressions, but
the size of the cache is limited and using compiled expressions directly
avoids the overhead associated with cache lookup.

Another advantage of using compiled expressions is that by precompiling
all of the expressions when the module is loaded, the compilation work
is shifted to application start time, instead of occurring at a point
where the program may be responding to a user action
"""
import re


def main():
    regexes = [
        re.compile(p)
        for p in ["this", "that"]
    ]

    text = "Does this text match the pattern?"

    print(f"Text: {text!r}")

    for regex in regexes:
        print(f"Seeking '{regex.pattern}' ->", end=" ")

        if regex.search(text):
            print("match!")
        else:
            print("no match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Findall}
\begin{lstlisting}[language=Python]
"""
Listing 1.18

findall() function returns all of the substrings of the input that match
the pattern without overlapping
"""
import re


def main():
    text = "abbaaabbbbaaaaa"
    pattern = "ab"

    for match in re.findall(pattern, text):
        print(f"Found {match!r}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Finditer}
\begin{lstlisting}[language=Python]
"""
Listing 1.19

finditer() returns an iterator that produces Match instances instead of
the strings returned by findall()
"""
import re


def main():
    text = "abbaaabbbbaaaa"
    pattern = "ab"

    for match in re.finditer(pattern, text):
        s = match.start()
        e = match.end()
        print(f"Found {text[s:e]!r} at {s:d}:{e:d}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Repetition}
\begin{lstlisting}[language=Python]
"""
Listing 1.21

There are five ways to express repetition in a pattern. A pattern followed
by the metacharacter * is repeated zero or more times. + means that the
pattern must appear at least once. Using ? means the pattern appears zero
or one time. For a specific number of occurrences, use {m} after the
pattern, where m is the number of times the pattern should repeat. To
allow a variable, but limited number of repetitions, use {m, n}, where
m is the minimum number of repetitions and n is the maximum. Leaving out
n ({m,}) means the value must appear at least m times, with no maximum
"""
import re
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            ("ab*", "a followed by zero or more b"),
            ("ab+", "a followed by one or more b"),
            ("ab?", "a followed by zero or one b"),
            ("ab{3}", "a followed by three b"),
            ("ab{2,3}", "a followed by two to three b")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Repetition Non Greedy}
\begin{lstlisting}[language=Python]
"""
Listing 1.22

When processing a repetition instruction, re will usually consume as much
of the input as possible, while matching the pattern. This so-called
greedy behaviour may result in fewer individual matches, or the matches
may include more of the input text than intended.

Greediness can be turned off by following the repetition instruction
with ?
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            ("ab*?", "a followed by zero or more b"),
            ("ab+?", "a followed by one or more b"),
            ("ab??", "a followed by zero or one b"),
            ("ab{3}?", "a followed by three b"),
            ("ab{2,3}?", "a followed by two to three b")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Charset}
\begin{lstlisting}[language=Python]
"""
Listing 1.23

A character set is a group of characters, any one of which can match at
that point in the pattern e.g. [ab] would match either a or b
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            ("[ab]", "either a or b"),
            ("a[ab]+", "a followed by one or more a or b"),
            ("a[ab]+?", "a followed by one or more a or b, not greedy")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Charset Exclude}
\begin{lstlisting}[language=Python]
"""
Listing 1.24

A character set can also be used to exclude specific characters. The carat
(^) means to look for characters that are not in the set following the
carat
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "This is some text -- with punctuation.",
        [(r"[^-. ]+", "sequences without -, ., or space")]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Charset Ranges}
\begin{lstlisting}[language=Python]
"""
Listing 1.25

As character sets grow larger, typing each character becomes tedious.
You can use chracter ranges as a more compact form
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "This is some text -- with punctuation.",
        [
            (r"[a-z]+", "sequences of lowercase letters"),
            (r"[A-Z]+", "sequences of uppercase letters"),
            (r"[a-zA-Z]+", "sequences of lower- or uppercase letters"),
            (r"[A-Z][a-z]+", "one uppercase followed by lowercase")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Charset Dot}
\begin{lstlisting}[language=Python]
"""
Listing 1.26

As a special case of a character set, the meta-character dot, or period
indicates that the pattern should match any single character in that
position

Combining the dot with repetition can result in very long matches, unless
the non-greedy form is used.
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            ("a.", "a followed by any one character"),
            ("b.", "b followed by any one character"),
            ("a.*b", "a followed by anything, ending in b"),
            ("a.*?b", "a followed by anything, ending in b, non-greedy")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Escape Codes}
\begin{lstlisting}[language=Python]
"""
Listing 1.27

An even more compact representation uses escape codes for several
predefined character sets
    \d  A digit
    \D  A non-digit
    \s  Whitespace (tab, space, newline, etc.)
    \S  Non-whitespace
    \w  Alphanumeric
    \W  Non-Alphanumeric
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "A prime #1 example!",
        [
            (r"\d+", "sequence of digits"),
            (r"\D+", "sequence of non-digits"),
            (r"\s+", "sequence of whitespace"),
            (r"\S+", "sequence of non-whitespace"),
            (r"\w+", "alphanumeric characters"),
            (r"\W+", "non-alphanumeric"),
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Escape Escapes}
\begin{lstlisting}[language=Python]
"""
Listing 1.28

To match the characters that are part of the regular expression syntax,
escape the characters in the search pattern.
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        r"\d+ \D+ \s+",
        [(r"\\.\+", "escape code")]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Anchoring}
\begin{lstlisting}[language=Python]
"""
Listing 1.29

The relative location can be specified in the input text where the pattern
should appear by using anchoring instructions
    ^   Start of string, or line
    $   End of string, or line
    \A  Start of string
    \Z  End of string
    \b  Empty string at the beginning or end of a word
    \B Empty string not at the beginning or end of a word
"""
import re
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "This is some text -- with punctuation.",
        [
            (r"^\w+", "word at start of string"),
            (r"\A\w+", "word at start of string"),
            (r"\w+\S*$", "word near end of string"),
            (r"\w+\S*\Z", "word near end of string"),
            (r"\w*t\w*", "word containing t"),
            (r"\bt\w+", "t at start of word"),
            (r"\w+t\b", "t at end of word"),
            (r"\Bt\B", "t not at start or end of word")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Match}
\begin{lstlisting}[language=Python]
"""
Listing 1.30

In situations where it is known in advance that only a subset of the full
input should be searched, the regular expression match can be further
constrained by telling re to limit the search range.

e.g. if pattern must appear at the front of the input, then using match()
instead of search() will anchor the search without having to explicitly
include an anchor in the search pattern
"""
import re


def main():
    text = "This is some text -- with punctuation"
    pattern = "is"

    print("Text   :", text)
    print("Pattern:", pattern)

    m = re.match(pattern, text)
    print("Match  :", m)
    s = re.search(pattern, text)
    print("Search :", s)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Fullmatch}
\begin{lstlisting}[language=Python]
"""
Listing 1.31

The fullmatch() method requires that the entire input string match
the pattern
"""
import re


def main():
    text = "This is some text -- with punctuation"
    pattern = "is"

    print("Text         :", text)
    print("Pattern      :", pattern)

    m = re.search(pattern, text)
    print("Search       :", m)

    s = re.fullmatch(pattern, text)
    print("Full match   :", s)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Search Substring}
\begin{lstlisting}[language=Python]
"""
Listing 1.32

The search() method of a compiled regular expression accepts optional
start and end position parameters to limit the search to a substring
of the input
"""
import re


def main():
    text = "This is some text -- with punctuation."
    pattern = re.compile(r"\b\w*is\w*\b")

    print("Text:", text)
    print()

    pos = 0
    while True:
        match = pattern.search(text, pos)
        if not match:
            break
        s = match.start()
        e = match.end()
        print("    {:>2d}  :  {:>2d} = '{}'".format(
            s, e-1, text[s:e]
        ))
        pos = e


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups}
\begin{lstlisting}[language=Python]
"""
Dissecting Matches with Groups

Searching for pattern matches is the basis of the powerful capabilities
provided by regular expressions. Adding groups to a pattern isolates
parts of the matching text, expanding those capabilities to create a
parser. Groups are defined by enclosing patterns in parentheses.

Any complete regular expression can be converted to a group and nested
within a larger expression. All the repetition modifiers can be applied
to the group as a whole, requiring the entire group pattern to repeat.
"""
from re_test_patterns import test_patterns


def main():
    test_patterns(
        "abbaaabbbbaaaaa",
        [
            (r"a(ab)", "a followed by literal ab"),
            (r"a(a*b*)", "a followed by 0-n a and 0-n b"),
            (r"a(ab)*", "a followed by 0-n ab"),
            ("a(ab)+", "a followed by 1-n ab")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Match}
\begin{lstlisting}[language=Python]
"""
Listing 1.34

To access the substrings matched by the individual groups within a pattern,
use the groups() method of the Match object

Match.groups() returns a sequence of strings in the order of the groups
within the expression that matches the string.
"""
import re


def main():
    text = "This is some text -- with punctuation."
    print(text)
    print()

    patterns = [
        (r"^(\w+)", "word at start of string"),
        (r"(\w+)\S*$", "word at end with optional punctuation"),
        (r"(\bt\w+)\W+(\w+)", "word starting with t, another word"),
        (r"(\w+t)\b", "word ending with t"),
    ]

    for pattern, desc in patterns:
        regex = re.compile(pattern)
        match = regex.search(text)
        print(f"'{pattern}'   ({desc})\n")
        print("   ", match.groups())
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Individual}
\begin{lstlisting}[language=Python]
"""
Listing 1.35

To ask for the match of a single group, use the group() method. This is
useful when grouping is being used to find parts of the string, but some
of the parts matched by groups are not needed in results

Group 0 represents the string matched by the entire expression, and
subgroups are numbered starting with 1 in the order that their left
parenthesis appears in the expression.
"""
import re


def main():
    text = "This is some text -- with punctuation."

    print("Input text            :", text)

    # Word starting with "t" then another word
    regex = re.compile(r"(\bt\w+)\W+(\w+)")
    print("Pattern               :", regex.pattern)

    match = regex.search(text)
    print("Entire match          :", match.group(0))
    print("Word starting with 't':", match.group(1))
    print("Word after 't' word   :", match.group(2))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Named}
\begin{lstlisting}[language=Python]
"""
Listing 1.36

Python extends the basic grouping syntax to add named groups. Using
names to refer to groups makes it easier to modify the pattern over
time, without having to also modify the code using the match results.

To set the name of a group, use the syntax (?P<name>pattern)

Use groupdict() to retrieve the dictionary mapping group names to
substrings from the match. Named patterns are included in the
ordered sequence returned by groups() as well.
"""
import re


def main():
    text = "This is some text -- with punctuation."
    print(text)
    print()

    patterns = [
        r"^(?P<first_word>\w+)",
        r"(?P<last_word>\w+)\S*$",
        r"(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)",
        r"(?P<ends_with_t>\w+t)\b"
    ]

    for pattern in patterns:
        regex = re.compile(pattern)
        match = regex.search(text)
        print(f"'{pattern}'")
        print(f"   ", match.groups())
        print(f"   ", match.groupdict())
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Nested}
\begin{lstlisting}[language=Python]
"""
Listing 1.38

Since a group is itself a complete regular expression, groups can be
nested within other groups to build even more complicated expressions
"""
from re_test_patterns_groups import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [(r"a((a*)(b*))", "a followed by 0-n a and 0-n b")]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Alternative}
\begin{lstlisting}[language=Python]
"""
Listing 1.39

Groups are also useful for specifying alternative patterns. Use the
pipe symbol (|) to indicate that either pattern should match.
"""
from re_test_patterns_groups import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            (r"a((a+)|(b+))", "a then seq. of a or seq. of b"),
            (r"a((a|b)+)", "a then seq. of [ab]")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Groups Noncapturing}
\begin{lstlisting}[language=Python]
"""
Listing 1.40

Defining a group containing a subpattern is also useful in cases where
the string matching subpattern is not part of what should be extracted
from the full text. These kinds of groups are called non-capturing.
Non-capturing groups can be used to describe repetition patterns or
alternatives, without isolating the matching portion of the string in
the value returned.

To create a non-capturing group, use (?:pattern)
"""
from re_test_patterns_groups import test_patterns


def main():
    test_patterns(
        "abbaabbba",
        [
            (r"a((a+)|(b+))", "capturing form"),
            (r"a((?:a+)|(?:b+))", "noncapturing")
        ]
    )


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Flags Ignorecase}
\begin{lstlisting}[language=Python]
"""
Listing 1.41

Option flags are used to change the way the matching engine processes an
expression. The flags can be combined using a bitwise OR operation, then
passed to compile(), search(), match() and other functions that accept a
pattern for searching

IGNORECASE causes literal characters and character ranges in the pattern
to match both uppercase and lowercase characters
"""
import re


def main():
    text = "This is some text -- with punctuation."
    pattern = r"\bT\w+"
    with_case = re.compile(pattern)
    without_case = re.compile(pattern, re.IGNORECASE)

    print(f"Text:\n  {text!r}")
    print(f"Pattern:\n  {pattern}")
    print("Case-sensitive:")
    for match in with_case.findall(text):
        print(f"  {match!r}")
    print("Case-insensitive:")
    for match in without_case.findall(text):
        print(f"  {match!r}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Flags Multiline}
\begin{lstlisting}[language=Python]
"""
Listing 1.42

Two flags affect how searching in multiline input works: MULTILINE and
DOTALL. The MULTILINE flag controls how the pattern matching code
processes anchoring instructions for text containing newline characters.
When multiline is turned on, the anchor rules for ^ and $ apply at the
beginning and end of each line, in addition to the entire string
"""
import re


def main():
    text = "This is some text -- with punctuation.\nA second line."
    pattern = r"(^\w+)|(\w+\S*$)"
    single_line = re.compile(pattern)
    multiline = re.compile(pattern, re.MULTILINE)

    print(f"Text:\n  {text!r}")
    print(f"Pattern:\n  {pattern}")
    print("Single Line:")
    for match in single_line.findall(text):
        print(f"  {match!r}")
    print("Multiline:")
    for match in multiline.findall(text):
        print(f"  {match!r}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Flags Dotall}
\begin{lstlisting}[language=Python]
"""
Listing 1.43

DOTALL is the other flag related to multiline text. Normally, the dot
character (.) matches everything in the input text except a newline
character. The flag allows the dot to match newlines as well
"""
import re


def main():
    text = "This is some text -- with punctuation.\nA second line."
    pattern = r".+"
    no_newlines = re.compile(pattern)
    dotall = re.compile(pattern, re.DOTALL)

    print(f"Text:\n  {text!r}")
    print(f"Pattern:\n  {pattern}")
    print("No newlines:")
    for match in no_newlines.findall(text):
        print(f"  {match!r}")
    print("Dotall:")
    for match in dotall.findall(text):
        print(f"  {match!r}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Flags Ascii}
\begin{lstlisting}[language=Python]
"""
Listing 1.44

Under Python 3, str objects use the full Unicode character set, and
regular expression processing on a str assumes that the pattern and
input text are both Unicode.

Those assumptions mean that the pattern \w+ will match both the words
"French" and "Français". To restrict escape codes to the ASCII character
set, as was the default in Python2, use the ASCII flag when compiling
the pattern or when calling the module level functions search() and
match()
"""
import re


def main():
    text = u"Français łzoty Österreich"
    pattern = r"\w+"
    ascii_pattern = re.compile(pattern, re.ASCII)
    unicode_pattern = re.compile(pattern)

    print("Text    :", text)
    print("Pattern :", pattern)
    print("ASCII   :", list(ascii_pattern.findall(text)))
    print("Unicode :", list(unicode_pattern.findall(text)))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Email Compact}
\begin{lstlisting}[language=Python]
"""
Listing 1.45

The compact format of regular expression syntax can become a hindrance
as expressions grow more complicated. As the number of groups in an
expression increases, it will be more work to keep track of why each
element is needed and how exactly the parts of the expression interact.

Using named groups helps mitigate these issues, but a better solution
is to use verbose mode expressions, which allow comments and extra
whitespace to be embedded in the pattern.

A pattern to validate the email addresses will illustrate how verbose
code makes working with regular expressions easier. The first version
recognizes addresses that end in .com, .org or .edu
"""
import re


def main():
    address = re.compile(r"[\w\d.+-]+@([\w\d.]+\.)+(com|org|edu)")

    candidates = [
        u"first.last@example.com",
        u"first.last+category@gmail.com",
        u"valid-address@mail.example.com",
        u"not-valid@example.foo"
    ]

    for candidate in candidates:
        match = address.search(candidate)
        print(f"{candidate:<30}  {'Matches' if match else 'No match'}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Email Verbose}
\begin{lstlisting}[language=Python]
"""
Listing 1.46

Converting the expression to a more verbose format will make it easier
to extend
"""
import re


def main():
    address = re.compile(
        r"""
        [\w\d.+-]+      # Username
        @
        ([\w\d.]+\.)+   # Domain name prefix
        (com|org|edu)   # TODO: support more top-level domains
        """,
        re.VERBOSE
    )
    
    candidates = [
        u"first.last@example.com",
        u"first.last+category@gmail.com",
        u"valid-address@mail.example.com",
        u"not-valid@example.foo"
    ]

    for candidate in candidates:
        match = address.search(candidate)
        print(f"{candidate:<30}  {'Matches' if match else 'No match'}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Email With Name}
\begin{lstlisting}[language=Python]
"""
Listing 1.47

This expanded version parses inputs that include a person's name and email
address, as might appear in an email header. The name comes first and
stands on its own, and the email address follows, surrounded by angle
brackets (< and >)
"""
import re


def main():
    address = re.compile(
        r"""
        # A name is made up of letters and may include "."
        # for title abbreviations and middle initials.
        ((?P<name>
            ([\w.,]+\s+)*[\w.,]+)
            \s*
            # Email addresses are wrapped in angle brackets < >, but
            # only if a name is found, so keep the start bracket in
            # this group
            <
        )? # The entire name is optional
        
        #The address itself: username@domain.tld
        (?P<email>
            [\w\d.+-]+      # Username
            @
            ([\w\d.]+\.)+   # Domain name prefix
            (com|org|edu)   # Limit the allowed top-level domains
        )
        
        >? # Optional closing angle bracket.
        """,
        re.VERBOSE
    )

    candidates = [
        u"first.last@example.com",
        u"first.last+category@gmail.com",
        u"valid-address@mail.example.com",
        u"not-valid@example.foo",
        u"First Last <first.last@example.com>",
        u"No Brackets first.last@example.com",
        u"First Last",
        u"First Middle Last <first.last@example.com>",
        u"First M. Last <first.last@example.com>",
        u"<first.last@example.com>"
    ]

    for candidate in candidates:
        print("Candidate: ", candidate)
        match = address.search(candidate)
        if match:
            print("   Name :", match.groupdict()["name"])
            print("   Email:", match.groupdict()["email"])
        else:
            print("   No Match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Flags Embedded}
\begin{lstlisting}[language=Python]
"""
Listing 1.48

In situations where flags cannot be added when compiling an expression,
such as when a pattern is passed as an argument to a library function
that will compile it later, the flags can be embedded inside the expression
string itself. For example, to turn case-insensitive matching on,
add (?i) to the beginning of the expression

Because the options control the way the entire expression is evaluated
or parsed, they should always appear at the beginning of the expression

Embedded flags can be combined by placing them within the same group,
for example (?im) turns on case-insensitive matching for multiline
strings
    ASCII       a
    IGNORECASE  i
    MULTILINE   m
    DOTALL      s
    VERBOSE     x
"""
import re


def main():
    text = "This is some text -- with punctuation"
    pattern = r"(?i)\bT\w+"
    regex = re.compile(pattern)
    print(f"Text     : {text}")
    print(f"Pattern  : {pattern}")
    print(f"Matches  : {regex.findall(text)}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Lookahead}
\begin{lstlisting}[language=Python]
"""
Listing 1.49

In many cases, it is useful to match a part of a pattern only if some
other part will also match.

For example, in the email parsing expression, the angle brackets were
marked as optional.

Realistically, the brackets should be paired, and the expression should
match only if both are present, or neither is. This modified version
of the expression uses a positive look ahead assertion to match
the pair.

The look ahead assertion syntax is (?=pattern)
"""
import re


def main():
    address = re.compile(
        r"""
        # A name is made up of letters and may include "."
        # for title abbreviations and middle initials.
        ((?P<name>
            ([\w.,]+\s+)*[\w.,]+)
            \s+
        ) # The name is no longer optional
        
        # LOOKAHEAD
        # Email addresses are wrapped in angle brackets, but only
        # if both are present or neither is
        (?= (<.*>$)         # Remainder wrapped in angle brackets
            |
            ([^<].*[^>]$)   # Remainder *not wrapped in angle brackets 
        )
        
        <? # Optional opening angle bracket
        
        # The address itself: username@domain.tld
        (?P<email>
            [\w\d.+-]+      # Username
            @
            ([\w\d.]+\.)+   # Domain name prefix
            (com|org|edu)   # Limit the allowed top-level domains
        )

        >? # Optional closing angle bracket.
        """,
        re.VERBOSE
    )

    candidates = [
        u"First Last <first.last@example.com>",
        u"No Brackets first.last@example.com",
        u"Open Bracket <first.last@example.com",
        u"Close Bracket first.last@example.com>",
    ]

    for candidate in candidates:
        print("Candidate: ", candidate)
        match = address.search(candidate)
        if match:
            print("   Name :", match.groupdict()["name"])
            print("   Email:", match.groupdict()["email"])
        else:
            print("   No Match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Negative Look Ahead}
\begin{lstlisting}[language=Python]
"""
Listing 1.50

A negative look ahead assertion ((?!pattern)) says that the pattern
does not match the text following the current point. For example,
the email recognition pattern could be modified to ignore the noreply
mailing address commonly used by automated systems
"""
import re


def main():
    address = re.compile(
        r"""
        ^
        
        # An address: username@domail.tld
        
        #Ignore noreply addresses
        (?!noreply@.*$)
        
        [\w\d.+-]+      # Username
        @
        ([\w\d.]+\.)+   # Domain name prefix
        (com|org|edu)   # Limit the allowed top-level domains
        
        $
        """,
        re.VERBOSE
    )

    candidates = [
        u"first.last@example.com",
        u"noreply@example.com"
    ]

    for candidate in candidates:
        print(f"Candidate: {candidate}")
        match = address.search(candidate)
        if match:
            print("   Match:", candidate[match.start():match.end()])
        else:
            print("   No match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Negative Look Behind}
\begin{lstlisting}[language=Python]
"""
Listing 1.51

Instead of looking ahead for noreply in the username portion of the
email address, the pattern can alternatively be written using a negative
look behind assertion after the username is matched using the syntax
(?<!pattern)

The expression must use a fixed-length pattern. Repetitions are allowed,
as long as there is a fixed number of them (no wildcards or ranges)
"""
import re


def main():
    address = re.compile(
        r"""
        ^

        # An address: username@domail.tld

        [\w\d.+-]+      # Username
        
        #Ignore noreply addresses
        (?<!noreply)
        
        @
        ([\w\d.]+\.)+   # Domain name prefix
        (com|org|edu)   # Limit the allowed top-level domains

        $
        """,
        re.VERBOSE
    )

    candidates = [
        u"first.last@example.com",
        u"noreply@example.com"
    ]

    for candidate in candidates:
        print(f"Candidate: {candidate}")
        match = address.search(candidate)
        if match:
            print("   Match:", candidate[match.start():match.end()])
        else:
            print("   No match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Look Behind}
\begin{lstlisting}[language=Python]
"""
Listing 1.52

A positive look behind assertion can be used to find text following a
pattern using the syntax (?<=pattern).

In the following example, the expression finds Twitter handles
"""
import re


def main():
    twitter = re.compile(
        r"""
        # A twitter handle: @username
        (?<=@)
        ([\w\d_]+)  # Username
        """,
        re.VERBOSE
    )

    text = """This text includes two Twitter handles.
    One for @ThePSF, and one for the author, @doughellmann
    """

    print(text)
    for match in twitter.findall(text):
        print(f"Handle: {match}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Refer To Group}
\begin{lstlisting}[language=Python]
"""
Listing 1.53

Matched values can be used in later parts of an expression. The easiest
way to achieve this is by referring to the previously matched group by
ID number, using \num
"""
import re


def main():
    address = re.compile(
        r"""
        
        # The regular name
        (\w+)           # First name
        \s+
        (([\w.]+)\s+)?  # Optional middle name or initial
        (\w+)           # Last name
        
        \s+
        
        <
        
        # The address: first_name.last_name@domain.tld
        (?P<email>
            \1
            \.
            \4
            @
            ([\w\d.]+\.)+   # Domain name prefix
            (com|org|edu)   # Limit the allowed top-level domains
        )
        
        >
        """,
        re.VERBOSE | re.IGNORECASE
    )

    candidates = [
        u"First Last <first.last@example.com>",
        u"Different Name <first.last@example.com>",
        u"First Middle Last <first.last@example.com>",
        u"First M. Last <first.last@example.com>"
    ]

    for candidate in candidates:
        print(f"Candidate: {candidate}")
        match = address.search(candidate)
        if match:
            print("  Match name :", match.group(1), match.group(4))
            print("  Match email:", match.group(5))
        else:
            print("  No match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Refer To Named Group}
\begin{lstlisting}[language=Python]
"""
Listing 1.54

Python's expression parser includes an extension that uses (?P=name) to
refer to the value of a named group matched earlier in the expression.
"""
import re


def main():
    address = re.compile(
        r"""

        # The regular name
        (?P<first_name>\w+)           # First name
        \s+
        (([\w.]+)\s+)?  # Optional middle name or initial
        (?P<last_name>\w+)           # Last name

        \s+

        <

        # The address: first_name.last_name@domain.tld
        (?P<email>
            (?P=first_name)
            \.
            (?P=last_name)
            @
            ([\w\d.]+\.)+   # Domain name prefix
            (com|org|edu)   # Limit the allowed top-level domains
        )

        >
        """,
        re.VERBOSE | re.IGNORECASE
    )

    candidates = [
        u"First Last <first.last@example.com>",
        u"Different Name <first.last@example.com>",
        u"First Middle Last <first.last@example.com>",
        u"First M. Last <first.last@example.com>"
    ]

    for candidate in candidates:
        print(f"Candidate: {candidate}")
        match = address.search(candidate)
        if match:
            print("  Match name :", match.groupdict()["first_name"], end=" ")
            print(match.groupdict()["last_name"])
            print("  Match email:", match.groupdict()["email"])
        else:
            print("  No match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Id}
\begin{lstlisting}[language=Python]
"""
Listing 1.55

The other mechanism for using back-references in expressions chooses a
different pattern based on whether a previous group matched. The syntax
for testing whether a group has matched is
    (?(id)yes-expression|no-expression)
where id is the group name or number, yes-expression is the pattern to
use if the group has a value, and no-expression is the pattern to use
otherwise
"""
import re


def main():
    address = re.compile(
        r"""
        ^
        
        # A name is made up of letters, and may include "."
        # for title abbreviations and middle initials
        (?P<name>
            ([\w.]+\s+)*[\w.]+
        )?
        \s*
        
        # Email addresses are wrapped in angled brackets, but
        # only if a name is found
        (?(name)
            # Remainder wrapped in angle brackets because
            # there is a name
            (?P<brackets>(?=(<.*>$)))
            |
            # Remainder does not include angle brackets without name
            (?=([^<].*[^>]$))
        )
        
        # Look for bracket only if the look-ahead assertion
        # found both of them
        (?(brackets)<|\s*)
        
        # The address itself: username@domain.tld
        (?P<email>
            [\w\d.+-]+      # Username
            @
            ([\w\d.]+\.)+   # Domain name prefix
            (com|org|edu)   # Limit the allowed top-level domains
        )
        
        # Look for a bracket only if the look-ahead assertion
        # found both of them.
        (?(brackets)>|\s*)
        
        $
        """,
        re.VERBOSE
    )

    candidates = [
        u"First Last <first.last@example.com>",
        u"No Brackets first.last@example.com",
        u"Open Bracket <first.last@example.com",
        u"Close Bracket first.last@example.com>",
        u"no.brackets@example.com"
    ]

    for candidate in candidates:
        print("Candidate:", candidate)
        match = address.search(candidate)
        if match:
            print("  Match name :", match.groupdict()["name"])
            print("  Match email:", match.groupdict()["email"])
        else:
            print("  No match")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Sub}
\begin{lstlisting}[language=Python]
"""
Listing 1.56

In addition to searching through text, re supports modifying text using
regular expressions as the search mechanism, and there replacements can
reference groups matched in the pattern as part of the substitution text.
Use sub() to replace all occurrences of a pattern with another string
"""
import re


def main():
    bold = re.compile(r"\*{2}(.*?)\*{2}")

    text = "Make this **bold**. This **too**."
    print("Text:", text)
    print("Bold:", bold.sub(r"<b>\1</b>", text))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Sub Named Groups}
\begin{lstlisting}[language=Python]
"""
Listing 1.57

To use named groups in the substitution, use the syntax \g<name>
"""
import re


def main():
    bold = re.compile(r"\*{2}(?P<bold_text>.*?)\*{2}")

    text = "Make this **bold**. This **too**."
    print("Text:", text)
    print("Bold:", bold.sub(r"<b>\g<bold_text></b>", text))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Sub Count}
\begin{lstlisting}[language=Python]
"""
Listing 1.58

Pass a value to count to limit the number of substitutions performed
"""
import re


def main():
    bold = re.compile(r"\*{2}(.*?)\*{2}")

    text = "Make this **bold**. This **too**."
    print("Text:", text)
    print("Bold:", bold.sub(r"<b>\1</b>", text, count=1))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Subn}
\begin{lstlisting}[language=Python]
"""
Listing 1.59

subn() works just like sub() except that it returns both the modified
string and the count of substitutions made
"""
import re


def main():
    bold = re.compile(r"\*{2}(.*?)\*{2}")

    text = "Make this **bold**. This **too**."
    print("Text:", text)
    print("Bold:", bold.subn(r"<b>\1</b>", text))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Paragraphs Findall}
\begin{lstlisting}[language=Python]
"""
Listing 1.60

str.split() is one of the most frequently used methods for breaking apart
strings to parse them. It supports only the literal values as separators,
though, and sometimes, a regular expression is necessary if the input is
not consistently formatted.

For example, many plain text markup languages define paragraph separators
as two or more newline (\n) characters. In this case, str.split()
cannot be used, because of the "or more" part of the definition

A strategy for identifying paragraphs using findall() would use a pattern
like (.+?)\n{2,}
"""
import re


def main():
    text = """Paragraph one
on two lines.

Paragraph two.

Paragraph three."""

    for num, para in enumerate(
        re.findall(r"(.+?)\n{2,}", text, flags=re.DOTALL)
    ):
        print(num, repr(para))
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Split}
\begin{lstlisting}[language=Python]
"""
Listing 1.61

The previous pattern fails for paragraphs at the end of the input text

Converting to re.split() instead of re.findall() handles the boundary
condition automatically and keeps the pattern simpler
"""
import re


def main():
    text = """Paragraph one
on two lines.

Paragraph two.

Paragraph three."""

    print("With findall:")
    for num, para in enumerate(
        re.findall(r"(.+?)(\n{2,}|$)", text, flags=re.DOTALL)
    ):
        print(num, repr(para))
        print()

    print("With split:")
    for num, para in enumerate(
        re.split(r"\n{2,}", text)
    ):
        print(num, repr(para))
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Re Split Groups}
\begin{lstlisting}[language=Python]
"""
Listing 1.62

Enclosing the expression in parentheses to define a group causes
split() to work more like str.partition, so it returns the separator
values as well as the other parts of the string
"""
import re


def main():
    text = """Paragraph one
on two lines.

Paragraph two.

Paragraph three."""

    print("With split:")
    for num, para in enumerate(
        re.split(r"(\n{2,})", text)
    ):
        print(num, repr(para))
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Difflib Differ}
\begin{lstlisting}[language=Python]
"""
Listing 1.64

The Differ class works on sequences of text lines and produces human-readable
deltas, or change instructions, including differences within individual
lines.

The default output produced by Differ is similar to the diff command-line
tool under Unix. It includes the original input values from both lists,
including common values, and markup data to indicate which changes were
made
    Lines prefixed with - were in the first sequence but not the second
    Lines prefixed with + were in the second sequence but not the first
    If a line has an incremental difference between versions, an extra
    line prefixed with ? is used to highlight the change within the new
    version
    If a line has not changed, it is printed with an extra blank space
    on the left column, so that it is aligned with the other output that
    may have differences

Breaking the text up into a sequence of individual lines before passing it
to compare() produces more readable output than passing in large strings
"""
import difflib
from difflib_data import *


def main():
    d = difflib.Differ()
    diff = d.compare(text1_lines, text2_lines)
    print("\n".join(diff))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Difflib Unified}
\begin{lstlisting}[language=Python]
"""
Listing 1.65

While the Differ class shows all of the input lines, a unified diff
includes only the modified lines and a bit of context. The unified_diff()
function produces this sort of output

The lineterm argument is used to tell unified_diff to skip appending
newlines to the control lines that it returns because the input lines
do not include them. Newlines are added to all the lines when they are
printed.

Using context_diff() produces similar readable output
"""
import difflib
from difflib_data import *


def main():
    diff = difflib.unified_diff(
        text1_lines,
        text2_lines,
        lineterm=""
    )
    print("\n".join(list(diff)))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Difflib Junk}
\begin{lstlisting}[language=Python]
"""
Listing 1.66

All of the functions that produce difference sequences accept arguments to
indicate which lines should be ignored and which characters within a line
should be ignored. These parameters can be used to skip over markup or
whitespace changes in two versions of a file

The default for Differ is to not ignore any lines or characters explicitly,
but rather to rely on the ability of SequenceMatcher to detect noise. The
default for ndiff() is to ignore space and tab characters
"""
# This example is adapted from the source for difflib.py
import difflib

A = " abcd"
B = "abcd abcd"


def show_results(match):
    print(f"  a    = {match.a}")
    print(f"  b    = {match.b}")
    print(f"  size = {match.size}")
    (i, j, k) = match
    print(f"  A[a:a+size] = {A[i:i+k]!r}")
    print(f"  B[b:b+size] = {B[j:j + k]!r}")


def main():
    print(f"A = {A!r}")
    print(f"B = {B!r}")

    print("\nWithout junk detection:")
    s1 = difflib.SequenceMatcher(None, A, B)
    match1 = s1.find_longest_match(0, len(A), 0, len(B))
    show_results(match1)

    print("\nTreat spaces as junk:")
    s2 = difflib.SequenceMatcher(lambda x: x == " ", A, B)
    match2 = s2.find_longest_match(0, len(A), 0, len(B))
    show_results(match2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Difflib Seq}
\begin{lstlisting}[language=Python]
"""
Listing 1.67

The SequenceMatcher class compares two sequences of any types, as long
as the values are hashable. It uses an algorithm to identify the longest
contiguous matching blocks from the sequences, elimination "junk" values
that do not contribute to the real data.

The function get_opcodes() returns a list of instructions for modifying
the first sequence to make it match the second. The instructions are
encoded as five-element typles, including a single instruction (the
"opcode") and two pairs of start and stop indexes into the sequences,
(denoted as i1, i2, j1, j2)

    Opcode          Definition
    "replace"       Replace a[i1:i2] with b[j1:j2]
    "delete"        Remove a[i1:i2] entirely
    "insert"        Insert b[j1:j2] at a[i1:i2]
    "equal"         The subsequences are already equal

This example compares two lists of integers and uses get_opcodes() to
derive the instructions for converting the original list into the newer
version. The modifications are applied in reverse order so that the
list indexes remain accurate after items are added and removed

Sequence Matcher works with custom classes, as well as built-in types,
as long as they are hashable
"""
import difflib


def main():
    s1 = [1, 2, 3, 5, 6, 4]
    s2 = [2, 3, 5, 4, 6, 1]

    print("Initial data:")
    print("s1 = ", s1)
    print("s2 = ", s2)
    print("s1 == s2: ", s1 == s2)
    print()

    matcher = difflib.SequenceMatcher(None, s1, s2)
    for tag, i1, i2, j1, j2 in reversed(matcher.get_opcodes()):
        if tag == "delete":
            print(f"Remove {s1[i1:i2]} from positions [{i1}:{i2}]")
            print("  before =", s1)
            del s1[i1:i2]
        elif tag == "equal":
            print(f"s1[{i1}:{i2}] and s2[{j1}:{j2}] are the same")
        elif tag == "insert":
            print(f"Insert {s2[j1:j2]} from s2[{j1}:{j2}] into s1 at {i1}")
            print("  before =", s1)
            s1[i1:i2] = s2[j1:j2]
        elif tag == "replace":
            print(f"Replace {s1[i1:i2]} from s1[{i1}:{i2}] with "
                  f"{s2[j1:j2]} from s2[{j1}:{j2}]")
            print("  before =", s1)
            s1[i1:i2] = s2[j1:j2]

        print("   after =", s1, "\n")

    print("s1 == s2:", s1 == s2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Difflib Data.Py}
\begin{lstlisting}[language=Python]
"""
Listing 1.63

The difflib module contains tools for computing and working with
differences between sequences. It is especially useful for comparing
text, and includes functions that produce reports using several common
difference formats
"""
text1 = """Lorem ipsum dolor sit amet, consectetuer adipiscing
elit. Integer eu lacus accumsan arcu fermentum euismod. Donec
pulvinar porttitor tellus. Aliquam venenatis. Donec facilisis
pharetra tortor. In nec mauris eget magna consequat
convalis. Nam sed sem vitae odio pellentesque interdum. Sed
consequat viverra nisl. Suspendisse arcu metus, blandit quis,
rhoncus ac, pharetra eget, velit. Mauris urna. Morbi nonummy
molestie orci. Praesent nisi elit, fringilla ac, suscipit non,
tristique vel, mauris. Curabitur vel lorem id nisl porta
adipiscing. Suspendisse eu lectus. In nunc. Duis vulputate
tristique enim. Donec quis lectus a justo imperdiet tempus."""

text1_lines = text1.splitlines()

text2 = """Lorem ipsum dolor sit amet, consectetuer adipiscing
elit. Integer eu lacus accumsan arcu fermentum euismod. Donec
pulvinar, porttitor tellus. Aliquam venenatis. Donec facilisis
pharetra tortor. In nec mauris eget magna consequat
convalis. Nam cras vitae mi vitae odio pellentesque interdum. Sed
consequat viverra nisl. Suspendisse arcu metus, blandit quis,
rhoncus ac, pharetra eget, velit. Mauris urna. Morbi nonummy
molestie orci. Praesent nisi elit, fringilla ac, suscipit non,
tristique vel, mauris. Curabitur vel lorem id nisl porta
adipiscing. Duis vulputate tristique enim. Donec quis lectus a
justo imperdiet tempus. Suspendisse eu lectus. In nunc."""

text2_lines = text2.splitlines()

\end{lstlisting}
\section{Doc Module Difflib.Py}
\begin{lstlisting}[language=Python]
"""
TODO: Finish difflib doc
difflib - Helpers for computing deltas

This module provides classes and functions for comparing sequences. It
can be used for example, for comparing files, and can produce difference
information in various formats, including HTML and context and unified
diffs.

class difflib.SequenceMatcher
    This is a flexible class for comparing pairs of sequences of any type
    so long as the sequence elements are hashable.

class difflib.Differ
    This is a class for comparing sequences of lines of text, and
    producing human-readable differences or deltas. Differ uses
    SequenceMatcher both to compare sequences of lines, and to compare
    sequences of characters within similar (near-matching) lines

    Each line of a Differ delta begins with a two-letter code:
        -       line unique to sequence 1
        +       line unique to sequence 2
                line common to both sequences
        ?       line not present in either input sequence

    Lines beginning with "?" attempt to guide the eye to intraline
    differences, and were not present in either input sequence.

class difflib.HtmlDiff
    This class can be used to create an HTML table (or a complete HTML
    file containing the table) showing a side by side, line by line
    comparison of text with inter-line and intra-line change highlights.
    The table can be generated in either full or contextual difference
    mode

    __init__(tabsize=8, wrapcolumn=None, linejunk=None,
        charjunk=IS_CHARACTER_JUNK)
        Initializes instance of HTMLDiff

        tabsize is an optional keyword argument to specify tab spacing
        and defaults to 8

        wrapcolumn is an optional keyword to specify column number where
        lines are broken and wrapped, defaults to None where lines are
        not wrapped.

        linejunk and charjunk are optional keyword arguments passed into
        ndiff

    The following methods are public:

    make_file(fromlines, tolines, fromdesc="", todesc="",
        context=False, numlines=5, *, charset="utf-8")
        Compares fromlines and tolines (lists of strings) and returns a
        string which is a complete HTML file containing a table showing
        line by line differences with inter-line and intra-line changes
        highlighted.

        fromdesc and todesc are optional keyword arguments to specify
        from/to file column header strings

        context and numlines are both optional keyword arguments. Set
        context to True when contextual differences are to be show, else
        the default is False to show the full files. numlines deaults
        to 5. When context is True, numlines controls the number of
        context lines which surround the difference highlights. When
        context is False, numlines controls the number of lines which
        are show before a difference highlight when using the "next"
        hyperlinks.

    make_table(fromlines, tolines, fromdesc="", todesc="",
        context=False, numlines=5, *, charset="utf-8")
        Compares fromlines and tolines (lists of strings) and returns a
        string which is a complete HTML table showing
        line by line differences with inter-line and intra-line changes
        highlighted.

        The arguments for this method are the same as make_file()


difflib.context_diff(a, b, fromfile="", tofile="",
    fromfiledate="", tofiledate="", n=3, lineterm="\n")
    Compare a and b (lists of strings); return a delta (a generator
    generating the delta lines) in context diff format.

    Context diffs are a compact way of showing just the lines that have
    changes plus a few lines of context. The changes are shown in a
    before/after style. The number of context lines is set by n which
    defaults to 3.

    For inputs that do not have trailing newlines, set the lineterm
    argument to "" so that the output will be uniformly newline free

    The context diff format normall has a header for filenames and
    modification times. Any or all of these may be specified using strings
    for fromfile, tofile, fromfiledate, and tofiledate.
"""
import sys
import difflib

s1 = ["bacon\n", "eggs\n", "ham\n", "guido\n"]
s2 = ["python\n", "eggy\n", "hamster\n", "guido\n"]

sys.stdout.writelines(
    difflib.context_diff(s1, s2, fromfile="before.py", tofile="after.py")
)

"""
difflib.get_close_matches(word, possibilities,
    n=3, cutoff=0.6)
    Return a list of the best "good enough" matches. word is a sequence
    for which close matches are desired (typically a string), and
    possibilities is a list of sequences against which to match
    word (typically a list of strings)
    
    Optional argument n (default 3) is the maximum number of close 
    matches to return. n must be greater than 0.
    
    Optional argument cutoff (default 0.6) is a float in the range [0,1]
    Possibilities that don't score at least that similar to word are
    ignored.
    
    The best (no more than n) matches among the possibilities are 
    returned in a list, sorted by similarity score, most similar first.
"""
difflib.get_close_matches("appel",
                          ["ape", "apple", "peach", "puppy"])

import keyword

difflib.get_close_matches("wheel",
                          keyword.kwlist)
difflib.get_close_matches("pineapple",
                          keyword.kwlist)
difflib.get_close_matches("accept",
                          keyword.kwlist)

"""
difflib.ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK)
    Compare a and b (list of strings); return a Differ-style
    delta (a generator generating the delta lines)
    
    Optional keyword parameters linejunk and charjunk are filtering
    functions (or None)
    
    linejunk: A function that accepts a single string argument, and
    returns true if the string is junk, or false if not. The default
    is None.
    
    charjunk: A function that accepts a character (a string of length
    1) and returns true if the character is junk, or false if not.
"""
diff = difflib.ndiff(
    "one\ntwo\nthree\n".splitlines(keepends=True),
    "ore\ntree\nemu\n".splitlines(keepends=True)
)

print(" ".join(diff), end="")

"""
difflib.restore(sequence, which)
    Return one of the two sequences that generated a delta
    
    Given a sequence produced by Differ.compar() or ndiff(), extract
    lines originating from file 1 or 2 (parameter which), stripping off
    line prefixes
"""
diff = difflib.ndiff(
    "one\ntwo\nthree\n".splitlines(keepends=True),
    "ore\ntree\nemu\n".splitlines(keepends=True)
)

diff = list(diff)  # materialize the generated delta into a list
print("".join(difflib.restore(diff, 1)), end="")
print("".join(difflib.restore(diff, 2)), end="")

"""
difflib.unified_diff(a, b, fromfile="", tofile="",
    fromfiledate="", tofiledate="", n=3, lineterm="\n")
    Compare a and b (list of strings); return a delta (a generator
    generating the delta lines) in unified diff format.
    
    Unified diffs are a compact way of showing just the lines that have
    changed plus a few lines of context. The changes are shown in an
    inline style. The number of context lines is set by n which defaults
    to three
"""
s1 = ["bacon\n", "eggs\n", "ham\n", "guido\n"]
s2 = ["python\n", "eggy\n", "hamster\n", "guido\n"]

sys.stdout.writelines(
    difflib.unified_diff(s1, s2, fromfile="before.py", tofile="after.py")
)

"""
difflib.diff_bytes(dfunc, a, b, fromfile=b"", tofile=b"",
fromfiledate=b"", tofiledate=b"", n=3, lineterm=b"\n")
    Compare a and b (list of bytes objects) using dfunct; yield a 
    sequence of delta lines (also bytes) in the format returned by
    dfunc. dunc must be a callable, typically either unified_diff() or
    context_diff()
    
    Allows you to compare data with unknown or inconsistent encoding.
    All inputs except n must be bytes objects, not str.

difflib.IS_LINE_JUNK(line)
    Returns True for ignorable lines. The line line is ignorable if line
    is blank or contains a single "#", otherwise it is not ignorable. 
    Used as default for parameter linejunk in ndiff() in older versions

difflib.IS_CHARACTER_JUNK(ch)
    Returns True for ignorable characters. The character ch is ignorable
    if ch is a space or a tab. Used as a default for charjunk in ndiff()
    
    
SequenceMatcher Objects
The SequenceMatcher class has this constructor:

class difflib.SequenceMatcher(isjunk=None, a="", b="",
    autojunk=True)
    Optional argument isjunk must be None (the default) or a one-argument
    function that takes a sequence element and returns true if and only
    if the element is "junk" and should be ignored. Passing None for 
    isjunk is equivalent to passing lambda x: False; in other words,
    no elements are ignored
    
    E.g.
        lambda x: x in " \t"
        if you are comparing lines as sequences of characters and don't
        want to synch up on blanks or hard tabs.
    
    The optional arguments a and b are sequences to be compared; both
    default to empty strings. The elements of both sequences must be
    hashable.
    
    The optional argument autojunk can be used to disable the automatic
    junk heuristic
    
    SequenceMatcher objects get three data attributes: bjunk is the set
    of elements of b which isjunk is True. bpopular is the set of 
    non-junk elements considered popular by the heuristic (if it is not
    disabled); b2j is a dict mapping the remaining elements of b to a
    list of positions where they occur. All three are reset whenever
    b is reset with set_seqs() or set_seq2()
    
    SequenceMatcher objects have the following methods:
    set_seqs(a, b)
        Set the two sequences to be compared
    
    SequenceMatcher computes and caches detailed information about the
    second sequence, so if you want to compare one sequence against
    many sequences, use set_seq2() to set the commonly used sequence
    once and call set_seq1() repeatedly, once for each of the other
    sequences
    
    set_seq1(a)
        Set the first sequence to be compared. The second sequence
        to be compared is not changed
    set_seq2(b)
        Set the second sequence to be compared. The first sequence
        to be compared is not changed.
        
    find_longest_match(alo, ahi, blo, bhi)
        Find longest matching block in a[alo:ahi] and b[blo:bhi]
        
        If isjunk was omitted or None, find_longest_match() returns
        (i, j, k) such that a[i:i+k] is equal to b[j:j+k] where 
        alo<=i<=i+k<=ahi and blo<=j<=k+k<=bhi. For all (i',j',k')
        meeting those conditions, the additional conditions 
        k >= k', i <= i' and if i == i', j <= j' are also met
        In other words, of all maximal matching blocks, return one
        that starts earliest in a, and of all those maximal matching
        blocks that start earliest in a, return the one that starts
        earliest in b
"""
s = difflib.SequenceMatcher(None, " abcd", "abcd abcd")
s.find_longest_match(0, 5, 0, 9)

"""
        If isjunk was provided, first the longest matching
        
"""
\end{lstlisting}
\section{Doc Module Re.Py}
\begin{lstlisting}[language=Python]
"""
re - Regular expression operations

Provides regular expression matching operations similar to those found
in Perl

Patterns and strings to be searched can be Unicode strings (str) as well
as 8-bit strings (bytes).
    Unicode and 8-bit cannot be mixed

Regular expressions use the backslash character ("\") to indicate special
forms or to allow special characters to be used without invoking their
special meaning. Use raw string notation to avoid

Regular expression operations are available as module-level functions
and methods on compiled regular expressions. The functions are shortcuts
that don't require you to compile a regex object first, but miss some
fine-tuning parameters.


Regular Expression Syntax

A regular expression specifies a set of strings that matches it; the
functions in this module let you check if a particular string matches
a given regular expression.

TODO: Finish re module documentation
"""
\end{lstlisting}
\section{Doc Module Stdtypes String Methods.Py}
\begin{lstlisting}[language=Python]
"""
String Methods

Strings implement all of the common sequence operations, along with the
additional methods described below.

Strings support two types of string formatting
    str.format(), Format String Syntax, Custom String Formatting
    printf-style formatting

Methods
    ---------------------------------------------------------------------
    str.capitalize()
        Returns a copy of the string with its first character capitalized
        and the rest lowercased.
    ---------------------------------------------------------------------
    str.casefold()
        Returns a casefolded copy of the string. Casefolded strings may
        be used for caseless matching.
        More aggressive than lowercasing, because it removes all case
        distinctions in the string
    ---------------------------------------------------------------------
    str.center(width[,fillchar])
        Returns centered in a string of length width. Padding done using
        specified fillchar. Original string returned if width is less
        than or equal to len(s)
    ---------------------------------------------------------------------
    str.count(sub[,start[,end]])
        Return the number of non-overlapping occurrences of substring
        sub in the range [start, end]. Optional arguments start and
        end are interpreted as in slice notation
    ---------------------------------------------------------------------
    str.encode(encoding="utf-8", errors="strict")
        Return an encoded version of the string as a bytes object.
        errors may be given to set a different error handling scheme.
        Default is "strict" which raises UnicodeError. Other possible
        values are "ignore", "replace", "xmcharrefreplace",
        "backslashreplace" and any other name registered via
        codecs.register_error()
    ---------------------------------------------------------------------
    str.endswith(suffix[,start[,end]])
        Return True if the string ends with the specified suffix,
        otherwise return False. Suffix can also be a tuple of
        suffixes to look for. With optional start, test beginning
        at that position. With optional end, stop comparing at that
        position.
    ---------------------------------------------------------------------
    str.expandtabs(tabsize=8)
        Return a copy of the string where all tab characters are replaced
        by one or more spaces, depending on the current column and the
        given tab size. Tab positions occur ever tabsize characters
        (default is 8 giving tab positions 0, 8, 16, ...)
        To expand the string, the current column is set to zero and
        the string is examined character by character.
            \t is replaced with one or more zeroes
            \n \r reset current column to zero
            any other character unchanged
    ---------------------------------------------------------------------
"""
"01\t012\t0123\t01234".expandtabs()
"01\t012\t0123\t01234".expandtabs(4)

"""
    ---------------------------------------------------------------------
    str.find(sub[,start[,end]])
        Return the lowest index in the string where substring sub is found
        withing the slice s[start:end]. Return -1 if sub is not found.
            Note, use "in" to test if substring occurs, only use find for
            index
    ---------------------------------------------------------------------
    str.format(*args, **kwargs)
        Perform a string formatting operation.
    ---------------------------------------------------------------------
    str.format_map(mapping)
        Similar to str.format(**mapping) except that mapping is used
        directly and not copied to a dict. Useful if for example mapping
        is a dict subclass
    ---------------------------------------------------------------------
"""


class Default(dict):
    def __missing__(self, key):
        return key


"{name} was born in {country}".format_map(Default(name="Guido"))

"""
    ---------------------------------------------------------------------
    str.index(sub[,start[,end]])
        Like find() but raise ValueError when substring is not found
    ---------------------------------------------------------------------
    str.isalnum()
        Return True if all characters in the string are alphanumeric and
        there is at least one character.
        False otherwise.
    ---------------------------------------------------------------------
    str.isalpha()
        Return True if all characters in the string are alphabetic and 
        there is at least one character, False otherwise. 
    ---------------------------------------------------------------------
    str.isascii()
        Returns True if the string is empty or all characters in the string
        are ASCII, False otherwise.
    ---------------------------------------------------------------------
    str.isdecimal()
        Returns True if all characters in the string are decimal characters
        and there is at least one character, False otherwise.
    ---------------------------------------------------------------------
    str.isdigit()
        Returns True if all characters in the string are digits and there
        is at least one character, False otherwise.
    ---------------------------------------------------------------------
    str.isidentifier()
        Returns True if the string is a valid identifier according to
        the language definition.
        Call keyword.iskeyword() to test whether string s is a reserved
        identifier, such as def and class
    ---------------------------------------------------------------------
"""
import keyword

("hello".isidentifier(), keyword.iskeyword("hello"))
("def".isidentifier(), keyword.iskeyword("def"))

"""
    ---------------------------------------------------------------------
    str.islower()
        Returns True if all cased characters in the string are lowercase
        and there is at least one cased character, False otherwise.
    ---------------------------------------------------------------------
    str.isnumeric()
        Returns True if all characters in the string are numeric characters
        and there is at least one character, False otherwise.
    ---------------------------------------------------------------------
    str.isprintable()
        Returns True if all characters in the string are printable or
        the string is empty. False otherwise.
    ---------------------------------------------------------------------
    str.isspace()
        Returns True if there are only whitespace characters in the string
        and there is at least one character, False otherwise.
    ---------------------------------------------------------------------
    str.istitle()
        Returns True if the string is a titlecased string and there is at
        least one character.
    ---------------------------------------------------------------------
    str.isupper()
        Returns True if all cased characters in the string are uppercase
        and there is at least one cased character, False otherwise.
    ---------------------------------------------------------------------
    str.join(iterable)
        Return a string which is the concatenation of the strings in
        iterable. A TypeError will be raised if there are any non-string
        values in iterable, including bytes objects. The separator between
        elements is the string providing this method.
    ---------------------------------------------------------------------
    str.ljust(width[,fillchar])
        Returns the string left justified in a string of length width.
        Padding is done using the specified fillchar.
        Original string is returned if width is less than or equal to
        len(s)
    ---------------------------------------------------------------------
    str.lower()
        Returns a copy of the string with all the cased characters
        converted to lowercase.
    ---------------------------------------------------------------------
    str.lstrip([chars])
        Return a copy of the string with leading characters removed. The
        chars argument is a string specifying the set of characters to be
        removed. If omitted or None, the chars argument defaults to 
        removing whitespace.
"""
"           spacious           ".lstrip()
"www.example.com".lstrip("cmowz.")

"""
    ---------------------------------------------------------------------
    static str.maketrans(x[,y[,z]])
        This static method returns a translation table usable for
        str.translate().
    ---------------------------------------------------------------------
    str.partition(sep)
        Split the string at the first occurrence of sep, and return a
        3-tuple containing the part before the separator, the separator
        itself and the part after the separator. If the separator is
        not found, return a 3-tuple containing the string itself, followed
        by two empty strings
    ---------------------------------------------------------------------
    str.replace(old, new[,count])
        Return a copy of the string with all occurrences of substring old
        replaced by new. If the optional argument count is given, only the
        first count occurrences are replaced.
    ---------------------------------------------------------------------
    str.rfind(sub[,start[,end]])
        Return the highest index in the string where substring sub is
        found, such that sub is contained within s[start:end]. Return -1
        if not found
    ---------------------------------------------------------------------
    str.rindex(sub[,start[,end]])
        Like rfind() but raises ValueError when the substring sub is not
        found.
    ---------------------------------------------------------------------
    str.rjust(width[,fillchar])
        Return the string right justified in a string of length width.
        Padding is done using fillchar. The original string is returned
        if width is less than or equal to len(s)
    ---------------------------------------------------------------------
    str.rpartition(sep)
        Split the string at the last occurrence of sep, and return a
        3-tuple containing the part before the separator, the separator
        itself and the part after the separator. If the separator is
        not found, return a 3-tuple containing the string itself, followed
        by two empty strings
    ---------------------------------------------------------------------
    str.rsplit(sep=None, maxsplit=-1)
        Return a list of the words in the string, using sep as the 
        delimiter string. If maxsplit is given, at most maxsplit splits 
        are done, the rightmost ones. If sep is not specified or None,
        any whitespace string is a separator.
    ---------------------------------------------------------------------
    str.rstrip([chars])
        Return a copy of the string with trailing characters removed. The
        chars argument is a string specifying the set of characters to be
        removed. If omitted or None, the chars argument defaults to 
        removing whitespace.
    ---------------------------------------------------------------------
"""
"           spacious           ".rstrip()
"mississippi".rstrip("ipz")

"""
    ---------------------------------------------------------------------
    str.split(sep=None, maxsplit=-1)
        Return a list of the words in a the string, using sep as the
        delimeter string. If maxsplit is given, at most maxsplit splits
        are done. If maxsplit is not specified or -1, then there is no
        limit on the number of splits (all possible splits are made).
        
        If sep is given, consecutive delimiters are not grouped together
        and are deemed to delimit emtpy strings. The sep argument may
        consist of multiple characters. Splitting an empty string with
        a specified separator returns ['']
        
        If sep is not specified or is None, a different splitting
        algorithm is applied: runs of consecutive whitespace are regarded
        as a single separator and the result will contain no empty strings
        at the start or end of the string if the string has leading or
        trailing whitespace.
        ---------------------------------------------------------------------
"""
"1,2,3".split(",")
"1,2,3".split(",", maxsplit=1)
"1,2,,3".split(",")
"1 2 3".split()
"1 2 3".split(maxsplit=1)
"    1   2    3    ".split()

"""
    ---------------------------------------------------------------------
    str.splitlines([keepends])
        Return a list of lines in the string, breaking at line boundaries.
        Line breaks are not included in the resulting list unless keepends
        is given and true.
        Split at universal newlines
            \n, \r, \r\n, \v or \x0b. \f or \x0c, \x1c, \x1d, \x1e,
            \x85, \u2028, \u2029
    ---------------------------------------------------------------------
"""
"ab c\n\nde fg\rkl\r\n".splitlines()
"ab c\n\nde fg\rkl\r\n".splitlines(keepends=True)
"".splitlines()
"One line\n".splitlines()
"".split("\n")
"Two lines\n".split("\n")

"""
    ---------------------------------------------------------------------
    str.startswith(prefix[,start[,end]])
        Returns True if string starts with the prefix, otherwise return 
        False. prefix can also be a tuple of prefixes to look for
    ---------------------------------------------------------------------
    str.strip([chars])
        Returns a copy of the string with the leading and trailing 
        characters removed. The chars argument is a string specifying the
        set of characters to be removed. If omitted or None, the chars 
        argument defaults to removing whitespace.
    ---------------------------------------------------------------------
"""
"    spacious    ".strip()
"www.example.com".strip("cmowz.")
comment_string = "#...........Section 3.2.1 Issue #32.......... "
comment_string.strip(".#! ")

"""
    ---------------------------------------------------------------------
    str.swapcase()
        Return a copy of the string with uppercase characters converted
        to lowercase and vice versa. Note that it is not necessarily true
        that s.swapcase().swapcase() == s
    ---------------------------------------------------------------------
    str.title()
        Return a titlecased version of the string where words start with an
        uppercase character and the remaining characters are lowercase.
        Note that the algorithm uses a simple definition of a word, thus
        apostrophes in contractions and possessives form word boundaries
        which may not be the desired result. A workaround for apostrophes
        can be constructed using regular expressions
    ---------------------------------------------------------------------
"""
"Hello world".title()
"they're bill's friends from the UK".title()

import re


def titlecase(s):
    return re.sub(r"[A-za-z]+('[A-Za-z]+)?",
                  lambda mo: mo.group(0).capitalize(),
                  s)


titlecase("they're bill's friends.")

"""
    ---------------------------------------------------------------------
    str.translate(table)
        Return a copy of the string in which each character has been mapped
        through the given translation table. The table must be an object that
        implements indexing via __getitem__(), typically a mapping or sequence.
    ---------------------------------------------------------------------
    str.upper()
        Returns a copy of the string with all the cased characters converted
        to uppercase.
        Note s.upper().isupper() might be False if s contains uncased characters
    ---------------------------------------------------------------------
    str.zfill(width)
        Return a copy of the string left filled with ASCII "0" digits to
        make a string of length width. The original string is returned if
        width is less than or equal to len(s)
    ---------------------------------------------------------------------
"""
"42".zfill(5)
"-42".zfill(5)

"""
printf-style String Formatting
    String objects have one unique built-in operation:
    the % operator.
    This is known as the string formatting or interpolation operator.
    Given format % values (where format is a string), % conversion
    specifications in format are replaced with zero or more elements of
    values.
    
    If format requires a single argument, values may be a single
    non-tuple object. Otherwise, values must be a tuple with exactly
    the number of items specified by the format string or a single
    mapping object e.g. dictionary
    
    A conversion specifier contains two or more characters and has
    the following components, which must occur in this order:
        1) %
        2) Mapping key (optional), consisting of a parenthesised 
        sequence of characters
        3) Conversion flags (optional)
        4) Minimum field width (optional)
        5) Precision (optional)
        6) Length Modifier (optional)
        7) Conversion type
        
    When the right argument is a dictionary, then the formats in
    the string must include a parenthesised mapping key into that
    dictionary inserted immediately after the % character. The
    mapping key selects the value to be formatted from the mapping 
"""
print("%(language)s has %(number)03d quote types." %
      {"language": "Python", "number": 2})

"""
    Conversion flag characters:
        #   Alternate form
        0   Zero padded numeric values
        -   Left adjusted
        " " Blank should be left before a positive number
        +   A sign character will precede the conversion
        
    Conversion types
        d   Signed integer decimal
        i   Signed integer decimal
        o   Signed octal value
        u   Obsolete
        x   Signed hexademical (lowercase)
        X   Signed hexademical (uppercase)
        e   Floating point exponential (lowercase)
        E   Floating point exponential (uppercase)
        f   Floating point decimal format
        F   Floating point decimal format
        g   Floating point format
        G   Floating point format
        c   Single character
        r   String (repr)
        s   String (str)
        a   String (ascii)
        %   No argument is converted
"""
\end{lstlisting}
\section{Doc Module String.Py}
\begin{lstlisting}[language=Python]
"""
string - Common String Operations

String constants
--------------------------------------------------------------------------
string.ascii_letters
    The concatenation of the ascii_lowercase and ascii_uppercase
    constants. Not locale-dependent
--------------------------------------------------------------------------
string.ascii_lowercase
    "abcdefghijklmnopqrstuvwxyz"
--------------------------------------------------------------------------
string.ascii_uppercase
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
--------------------------------------------------------------------------
string.digits
    "0123456789"
--------------------------------------------------------------------------
string.hexdigits
    "0123456789abcdefABCDEF"
--------------------------------------------------------------------------
string.octdigits
    "01234567"
--------------------------------------------------------------------------
string.punctuation
    !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
--------------------------------------------------------------------------
string.printable
    String of ASCII characters which are considered printable. This is
    a combination of digits, ascii_letters, punctuation, and whitespace
--------------------------------------------------------------------------
string.whitespace
    A string containing all ASCII characters that are considered
    whitespace. This includes the characters space, tab, linefeed,
    return, formfeed and vertical tab
--------------------------------------------------------------------------


Custom String Formatting
    The built-in string class provides the ability to do complex variable
    substitutions and value formatting via the format() method.
    The Formatter class in the string module allows you to create
    and customize your own string formatting behaviours using the same
    implementation as the built-in format() method

class string.Formatter
    The Formatter class has the following public methods:
    ----------------------------------------------------------------------
    format(format_string, /, *args, **kwargs_
        Primary API method. Takes a format string and an arbitrary set of
        positional and keyword arguments. It is just a wrapper that calls
        vformat()
        - from version 3.7, format string argument is now positional-only
    ----------------------------------------------------------------------
    vformat(format_string, args, kwargs)
        Does the actual work of formatting. It is exposed as a separate
        function for cases where you want to pass in a predefined
        dictionary of arguments, rather than unpacking and repacking
        the dictionary os individual arguments using *args and **kwargs
        Does the work of breaking up the format string into character data
        and replacement fields. Calls the various methods below
    ----------------------------------------------------------------------

    The Formatter defines a number of methods that are intended to be
    replaced by subclasses:
    ----------------------------------------------------------------------
    parse(format_string)
    Loop over the format_string and return an iterable of tuples
    (literal_text, field_name, format_spec, conversion)
    Values in the tuple conceptually represent a span of literal
    text followed by a single replacement field.
    If there is no literal text, then literal_text will be
    a zero length string. If there is no replacement field, then the
    values of field_name, format_spec and conversion will be None
    ----------------------------------------------------------------------
    get_field(field_name, args, kwargs)
    Given field_name as returned by parse, conver it to an object to be
    formatted. Returns a tuple (obj, used_key).
    Return value used_key has the same meaning as the key parameter to
    get_value()
    ----------------------------------------------------------------------
    get_value(key, args, kwargs)
    Retrieve a given field value. The key value will either be an integer
    or string. If it is an integer, represents the index of the positional
    argument in args. If it is a string, represents named argument in
    kwargs.

    args parameter set to list of positional arguments to vformat(),
    kwargs is set to dictionary of keyword arguments

    For compound field names, these functions are only called for the
    first component of the field name; subsequent components are handled
    through normal attribute and indexing operations.

    If index or keyword refers to an item that does not exist, then an
    IndexError or KeyError should be raised.
    ----------------------------------------------------------------------
    check_unused_args(used_args, args, kwargs)
    Implement checking for unused arguments if desired. check_unused_args()
    is assumed to raise an exception if the check fails
    ----------------------------------------------------------------------
    format_field(value, format_spec)
    simply calls the global format() built-in. This method is provided so
    that subclasses can override it
    ----------------------------------------------------------------------
    convert_field(value, conversion)
    Converts the value (returned by get_field()) given a conversion type
    (as in the tuple returned by the parse() method). The default version
    understands "s" (str), "r" (repr) and "a" (ascii) conversion types
    ----------------------------------------------------------------------


Format String Syntax
    Format strings contain "replacement fields" surrounded by curly
    braces {}. Anything that is not contained in braces is considered
    literal text, which is copied unchanged to the output.
    If you need to include a brace character in the literal text,
    it can be escaped by doubling: {{ and }}

    The field_name itself begins with an arg_name that is either a
    number or a keyword. If its a number, it refers to a positional
    argument. If it's a keyword, refers to a named keyword.

    Grammar for a replacement field:
    replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"
    field_name        ::=  arg_name ("." attribute_name | "[" element_index "]")*
    arg_name          ::=  [identifier | digit+]
    attribute_name    ::=  identifier
    element_index     ::=  digit+ | index_string
    index_string      ::=  <any source character except "]"> +
    conversion        ::=  "r" | "s" | "a"
    format_spec       ::=  <described in the next section>

    An expression of the form ".name" selects the named attribute
    using getattr(), while an expression of the form "[index]" does
    an index lookup using __getitem__()
"""
eg1 = "First, thou shalt count to {0}"  # First positional argument
eg2 = "Bring me a {}"  # Implicitly references first positional argument
eg3 = "From {} to {}"  # Same as "From {0} to {1}"
eg4 = "My quest is {name}"  # References keyword argument
eg5 = "Weight in tons = {0.weight}"  # "weight" attribute of first positional arg
eg6 = "Units destroyed: {players[0]}"  # First element of keyword arg players


class WeightObject:
    def __init__(self, weight):
        self.weight = weight


weight_obj = WeightObject(10)
players = [100, 90, 80]

eg1.format(10)
eg2.format("knife")
eg3.format("A", "B")
eg4.format(name="Python")
eg5.format(weight_obj)
eg6.format(players=players)

"""
    The conversion field causes a type coercion before formatting.
    Normally, the formatting is done by the __format__() method of
    the value itself, however, you can cast to string to override
    the default method.

    Three conversion flags are supported
        "!s" calls str()
        "!r" calls repr()
        "!a" calls ascii()
"""
eg7 = "Harold's a clever {0!s}"  # Calls str()
eg8 = "Bring out the holy {name!r}"  # Calls repr()
eg9 = "More {!a}"  # Calls ascii() on the argument


class PrintObj:
    def __init__(self, init):
        self.attr = init

    def __str__(self):
        return "__str__ " + str(self.attr)

    def __repr__(self):
        return "__repr__\t\n" + str(self.attr)


print_obj = PrintObj(1)
eg7.format(print_obj)
eg8.format(name=print_obj)
eg9.format(print_obj)

"""
    The format_spec field contains a specification of how the value 
    should be presented, including such details as field width,
    alignment, padding, decimal precision and so on.
    Each value type can define its own "formatting mini-language"
    or interpretation of the format_spec
    
    Most built-in types support a common formatting mini-language
    
    A format_spec field can also include nested replacement fields
    within it. These nested replacement fields may contain a field name,
    conversion flag and format specification, but deeper nesting is
    not allowed. Replacement fields are substituted before format_spec
    is interpreted.
    

Format Specification Mini-Language
    "Format specifications" are used within replacement fields contained
    within a format string to define how individual values are 
    presented. They can also be passed directly to the built-in format()
    function.
    
    A general convention is that an empty format specification produces
    the same result as if you had called str() on the value. A non-empty
    format specification typically modifies the result
    
    The general form of a standard format specifier is:
    format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
    fill            ::=  <any character>
    align           ::=  "<" | ">" | "=" | "^"
    sign            ::=  "+" | "-" | " "
    width           ::=  digit+
    grouping_option ::=  "_" | ","
    precision       ::=  digit+
    type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
    
    If a valid align value is specified, it can be preceded by a fill
    character that can be any character and defaults to a space if
    omitted. It is not possible to use a literal curly brace ("{" or :}")
    as the fill character in a formatted string literal or when using the
    str.format() method.
    
    < Forces left-alignment within available space
    < Forces right-alignment within available space
    = Forces padding to be placed after the sign (if any) but before
    the digits
    ^ Forces the field to be centered
    
    Unless a minimum field width is defined, the field width will always
    be the same size as the data to fill it, so that the alignment option
    has no meaning in this case.
    
    The sign option is only valid for number types
    + indicates that a sign should be used for both positive as well
    as negative numbers
    - indicated that a signed should be used only for negative numbers
    space indicates that a leading space should be used on positive numbers,
    and a minus sign on negative numbers
    
    "#" option causes the "alternate form" to be used for conversion.
    Only valid for integer, float, complex and Decimal types.
    
    "," signals the use of a comma for a thousands separator.
    
    "_" signals the use of an underscore for a thousands separator
    
    width is a decimal integer defining the minimum total field width,
    including any prefixes, separators and other formatting characters
    
    precision determines how many digits should be displayed after the 
    decimal point for a floating point value. For non number types,
    indicates the maximum field size
    
    type determines how the data should be presented
        string
            "s" String format
            None Same as "s"
        
        integer
            "b" binary
            "c" converts integer to unicode character
            "d" decimal integer
            "o" octal integer
            "x" hex format lowercase
            "X" hex format uppercase
            "n" number
            None Same as "d"
        
        floating point
            "e" Exponent notation lowercase
            "E" Exponent notation uppercase
            "f" Fixed-point notation
            "F" Fixed-point notation but converts nan to NAN and inf to INF
            "g" General format. For precision p>=1, round number to p 
            significant digits
            "G" same as "g" but switches to "E" if the number gets too large
            "n" Number, same as "g"
            "%" Percentage - multiples number by 100 and displays "f"%
            None Similar to g except fixed-point notation will have at least
            one digit past the decimal point


Format Examples
"""
# Accessing argument by position:
"{0}, {1}, {2}".format("a", "b", "c")
"{}, {}, {}".format("a", "b", "c")
"{2}, {1}, {0}".format("a", "b", "c")
"{2}, {1}, {0}".format(*"abc")
"{0}{1}{0}".format("abra", "cad")

# Accessing arguments by name:
"Coordinates: {lattitude}, {longitude}".format(lattitude="37.24N", longitude="-115.81W")
coord = {"lattitude": "37.24N", "longitude": "-115.81W"}
"Coordinates: {lattitude}, {longitude}".format(**coord)

# Accessing arguments' attributes:
c = 3 - 5j
("The complex number {0} if formed from the real part {0.real} "
 "and the imaginary part {0.imag}").format(c)


class Point:
    def __init__(self, x, y):
        (self.x, self.y) = (x, y)

    def __str__(self):
        return "Point({self.x}, {self.y})".format(self=self)


str(Point(4, 2))

# Accessing arguments' items:
coord = (3, 5)
"X: {0[0]}; Y: {0[1]}".format(coord)

# Replacing %s and %r
"repr() shows quotes: {!r}; str() doesn't: {!s}".format("test1", "test2")

# Aligning text and specifying a width:
"{:<30}".format("left aligned")
"{:>30}".format("right aligned")
"{:^30}".format("centered")
"{:*^30}".format("centered")  # use "*" as fill char

# Replacing %=f, %-f and % f and specifying a sign
"{:+f}; {:+f}".format(3.14, -3.14)  # show it always
"{: f}; {: f}".format(3.14, -3.14)  # show space for positive
"{:-f}; {:-f}".format(3.14, -3.14)  # show only minus

# Replacing %x and %o and converting the value to different bases
# format also supports binary numbers
"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}".format(42)
"int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}".format(42)

# Using the comma as a thousands separator:
"{:,}".format(1234567890)

# Expressing a percentage
points = 19
total = 22
"Correct answers: {:.2%}".format(points/total)

# Use type-specific formatting
import datetime

d = datetime.datetime(2010, 7, 4, 12, 15, 58)
'{:%Y-%m-%d %H:%M:%S}'.format(d)

#Nesting arguments and more complex examples
for align, text in zip("<^>", ["left", "center", "right"]):
    print("{0:{fill}{align}16}".format(text, fill=align, align=align))

octets = [192, 168, 0, 1]
"{:02X}{:02X}{:02X}{:02X}".format(*octets)

width = 5
for num in range(5, 12):
    for base in "dXob":
        print("{0:{width}{base}}".format(num, base=base, width=width), end=" ")
    print()

"""
Template strings

Template strings provide simpler string substitutions as described in
PEP292. Primary use case is for internationalization

Template strings support $-based substitutions using the following
rules:
    $$ is an escape
    $identifier names a substitution placeholder
        identifier restricted to any case insensitive ASCII alphanumeric
        string that starts with an underscore or ASCII letter,
    ${identifier} is equivalent to $identifier but required when valid
    identifier characters follow the placeholder but are not part of
    the placeholder e.g. "${noun}ification"
    
Any other appearance of $ results in ValueError being raised

The string module provides a Template class that implements these rules

class string.Template
    The constructor takes a single argument which is the template string
    ----------------------------------------------------------------------
    substitute(mapping={}, /, **kwds)
        Performs the template substitution, returning a new string. 
        mapping is any dictionary-like object with keys that match the
        placeholders in the template.
        Alternatively, you can provide keyword arguments. When both
        mapping and kwds are given, and there are duplicates, the
        placeholders from kwds take precedence.
    safe_substitute(mapping={}, /, **kwds)
        Like substitute(), except that if placeholders are missing from
        mapping and kwds, instead of raising a KeyError exception, the
        original placeholder will appear in the resulting string intact.
        Also, any other appearances of $ will return $ instead of raising
        Value Error
    template
        This is the object passed to the constructor's template argument.
        In general, you shouldn't change it but read-only access is not
        enforced
"""
import string

s = string.Template("$who likes $what")
s.substitute(who="tim", what="kung pao")

d = dict(who="tim")
string.Template("Give $who $100").substitute(d)  # ValueError
string.Template("$who likes $what").substitute(d)  # KeyError
string.Template("$who likes $what").safe_substitute(d)

"""
Advanced usage
    You can derive subclasses of Template to customize the placeholder
    syntax, delimiter character, or the entire regular expression used
    to parse template strings.
    
    To do this, you can override these class attributes
        delimiter 
            This is the literal string describing a placeholder introducing 
            delimiter. Default is $. This should noe be a regular expression
        idpattern
            The regular expression describing the pattern for non-braced 
            placeholders. If given and braceidpattern is None, this pattern
            will also apply to braced placeholders
        braceidpattern
            Like idpattern but describes the pattern for braced placeholders.
            Defaults to None which means fall back to idpattern.
        flags
            regular expression flags that will be applied when compiling
            the regular expression used for recognising substitutions. 
            Default is re.IGNORECASE. re.VERBOSE is always added so that
            custom idpatterns must follow conventions for verbose regular
            expressions.
            
        Alternatively, you can provide the entire regular expression pattern
        by overriding the class attribute pattern. If you do this, the
        regular expression object must have four named capturing groups.
            escaped
                Group matches escape sequence e.g. $$
            named
                Group matches unbraced placeholder name. Should not include
                the delimiter in the capturing group
            braced
                Group matches the brace enclosed placeholder name. Should not
                include either the delimiter or braces in the capturing group
            invalid
                Group matches any other delimiter pattern (usually a single
                delimiter), and it should appear last in the regular expression


Helper Functions
    string.capwords(s, sep=None)
        Split the argument into words using str.split(), capitalize each
        word using str.capitalize(), and join the capitalized words using
        str.join(). If the optional argument sep is absent or None, runs
        of whitespace characters are replaced by a single space and leading
        and trailing whitespace are removed, otherwise sep is used to split
        and join the words

            
                
"""
\end{lstlisting}
\section{Doc Module Textwrap.Py}
\begin{lstlisting}[language=Python]
"""
textwrap - Text wrapping and filling

The textwrap module provides some convenience functions, as well as
TextWrapper, the class that does all the work

Use TextWrapper if filling or wrapping multiple strings for efficiency
------------------------------------------------------------------------
textwrap.wrap(text, width=70, **kwargs)
    Wraps the single paragraph in text (a string) so that every line is
    at most width characters long. Returns a list of output lines,
    without final newlines.

    Optional keyword arguments correspond to the instance attributes of
    TextWrapper. width defaults to 70
------------------------------------------------------------------------
textwrap.fill(text, width=70, **kwargs)
    Wraps the single paragraph in text, and returns a single string
    containing the wrapped paragraph. fill() is shorthand for
        "\n".join(wrap(text, ...
    Accepts exactly the same keyword arguments as wrap()
------------------------------------------------------------------------
textwrap.shorten(text, width, **kwargs)
    Collapse and truncate the given text to fit the given width.

    First the whitespace in text is collapsed (all whitespace is replaced
    by single spaces). If the result fits in the width, it is returned.
    Otherwise, enough words are dropped from the end so that the remaining
    words plus the placeholder fit within width

    Optional keyword arguments correspond to the instance attributes of
    TextWrapper.
------------------------------------------------------------------------
"""
import textwrap

textwrap.shorten("Hello world!", width=12)
textwrap.shorten("Hello world!", width=11)
textwrap.shorten("Hello world!", width=10, placeholder="...")

"""
------------------------------------------------------------------------
textwrap.dedent(text)
    Removes any common leading whitespace from every line in text.
    
    This can be used to make triple_quoted strings line up with the left
    edge of the display, while still presenting them in source code
    indented form.
    
    Both tabs and spaces are both treated as whitespace, but they are
    not equal "  hello" and "\thello" are considered to have no common
    leading whitespace
    
    Lines containing only whitespace are ignored in the input and 
    normalized to a single newline character in the output.
------------------------------------------------------------------------
"""


def test():
    s = """\
    hello
        world
    """
    print(repr(s))
    print(repr(textwrap.dedent(s)))


test()

"""
------------------------------------------------------------------------
textwrap.indent(text, prefix, predicate=None)
    Add prefix to the beginning of selected lines in text
    
    Lines are serparated by calling text.splitlines(True)
    
    By default, prefix is added to all lines that do not consist solely
    of whitespace (including any line endings)
    
    The optional predicate argument can be used to control which lines
    are indented.
------------------------------------------------------------------------
"""
s = "hello\n\n \nworld"
textwrap.indent(s, "    ")

print(textwrap.indent(s, "+ ", lambda line: True))

"""
wrap(), fill() and shorten() work by creating a TextWrapper instance and
calling a single method on it. That instance is not reused, so for
applications that process many text strings using wrap() and/or fill(),
it may be more efficient to create your own TextWrapper object.

Text is preferably wrapped on whitespaces and right after the hyphens in
hyphenated words; only then will long words be broken if necessary, unless
TextWrapper.break_long_words is set to false

class textwrap.TextWrapper(**kwargs)
    The TextWRapper constructor accepts a number of optional keyword
    arguments. Each keyword argument corresponds to an instance
    attribute, so for example
"""
wrapper = textwrap.TextWrapper(initial_indent="* ")
#is the same as
wrapper = textwrap.TextWrapper()
wrapper.initial_indent = "* "

"""
    You can re-use the same TextWrapper object many times, and you can
    change any of its options through direct assignment to instance
    attributes between uses.
    
    The textwrapper instance attributes are as follows
    --------------------------------------------------------------------
    width
        (default: 70) The maximum length of wrapped lines. As long
        as there are no individual words in the input text longer than
        width, TextWrapper guarantees that no output line will be longer
        than width characters
    --------------------------------------------------------------------
    expand_tabs
        (default: True) If true, then all tab characters in text will be
        expanded to spaces using the expandtabs() method of text
    --------------------------------------------------------------------
    tabsize
        (default: 8) If expand_tabs is true, then all tab characters in 
        text will be expanded to zero or more spaces, depending on the
        current columnb and the given tab size
    --------------------------------------------------------------------
    replace_whitespace
        (default: True) If true, after tab expansion, but before wrapping,
        the wrap() method will replace each whitespace character with a
        single space. The whitespace characters replaced are: tab, newline,
        vertical tab, formfeed and carriage return ("\t\n\v\f\r")
    --------------------------------------------------------------------
    drop_whitespace
        (default: True) If true, whitespace at the beginning and ending of
        every line (after wrapping but before indenting) is dropped. 
        Whitespace at the beginning of the paragraph, however, is not dropped
        if non-whitespace follows it. If whitespace being dropped takes up
        and entire line, the whole line is dropped
    --------------------------------------------------------------------
    initial_indent
        (default: "") String that will be prepended to the first line of
        wrapped output. Counts towards the length of the first line. The
        empty string is not indented
    --------------------------------------------------------------------
    subsequent_indent
        (default: "") String that will be prepended to all lines of wrapped
        output except the first. Counts towards the length of each line
        except the first
    --------------------------------------------------------------------
    fix_sentence_endings
        (default: False) If true, TextWrapper attempts to detect sentence
        endings and ensure that sentences are always separated by exactly
        two spaces. This is generally desired for text in a monospaced font.
        However, the sentence detection algorithm is imperfect. 
        Assumes that a sentence ending consists of lowercase letter followed
        by ".", "!" or "?", possibly followed by one of '"' or "'", followed
        by a space.
        Specific to English language texts
    --------------------------------------------------------------------
    break_long_words
        (default: True) If true, wrapping will occur preferably on 
        whitespaces and right after hyphens in compound words, as is
        customary in English. If false, only whitespaces will be considered
        as potentially good places for line breaks, but you need to set
        break_long_words to false if you want truly insecable words.
    --------------------------------------------------------------------
    max_lines
        (default: None) If not None, then the output will contain at most
        max_lines lines, with placeholder appearing at the end of the
        output
    --------------------------------------------------------------------
    palceholder
        (default: " [...]") String that will appear at the end of the output
        text if it has been truncated.
    --------------------------------------------------------------------
    
    TextWrapper Public methods:
    --------------------------------------------------------------------
    wrap(text)
        Wraps the single paragraph in text (a string) so every line is at
        most width characters long. All wrapping options are taken from
        instance attributes of the TextWrapper instance. Returns a list
        of output lines, without final newlines. If the wrapped output
        has no content, the returned list is empty.
    --------------------------------------------------------------------
    fill(text)
        Wraps the single paragraph in text and returns a single string
        containing the wrapped paragraph
    --------------------------------------------------------------------
"""

\end{lstlisting}
\section{Re Test Patterns Groups.Py}
\begin{lstlisting}[language=Python]
"""
Listing 1.37
"""
import re


def test_patterns(text, patterns):
    """
    Given source text and a list of patterns, look for matches for
    each pattern within the text and print them to stdout
    :param text:
    :param patterns:
    :return:
    """
    # Look for each pattern in the text and print the results
    for pattern, desc in patterns:
        print(f"{pattern!r}  ({desc})")
        print(f"  {text!r}")
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            prefix = " " * (s)
            print(f"  {prefix}{text[s:e]!r}{' ' * (len(text) - e)}  ",
                  end=" ")
            print(match.groups())
            if match.groupdict():
                print(f"{' ' * (len(text) - s)}{match.groupdict()}")
        print()
    return

\end{lstlisting}
\section{Re Test Patterns.Py}
\begin{lstlisting}[language=Python]
"""
Listing 1.20

Regular expressions support more powerful patterns than simple literal
text strings. Patterns can repeat, can be anchored to different logical
locations within the input, and can be expressed in compact forms that
do nto require every literal character to be present in the pattern.

All of these features are used by combining literal text values with
meta-characters that are part of the regular expression pattern syntax
implemented by re
"""
import re


def test_patterns(text, patterns):
    """
    Given source text and a list of patterns, look for matches for each
    pattern within the text and print them to stdout.
    :param text:
    :param patterns:
    :return:
    """
    # Look for each pattern in the text and print the results
    for pattern, desc in patterns:
        print(f"'{pattern}' ({desc})\n")
        print(f"     '{text}")
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            substr = text[s:e]
            n_backslashes = text[:s].count("\\")
            prefix = "." * (s + n_backslashes)
            print(f"     {prefix}'{substr}'")
        print()
    return


def main():
    test_patterns("abbaaabbbbaaaaa",
                  [
                      ("ab", "'a' followed by 'b'")
                  ])


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Textwrap Example.Py}
\begin{lstlisting}[language=Python]
"""
Listing 1.8

The textwrap module can be used to format text for output in situations
where pretty-printing is desired. Offers programmatic functionality
similar to the paragraph wrapping or filling features found in many
text editors and word processors
"""
sample_text = """
    The textwrap module can be used to format text for output in 
    situations where pretty-printing is desired. Offers programmatic 
    functionality similar to the paragraph wrapping or filling features 
    found in many text editors and word processors
"""
\end{lstlisting}
\chapter{Chapter02}
\section{Enum Create}
\begin{lstlisting}[language=Python]
"""
Listing 2.1

Python includes several standard programming data structures, such as
list, tuple, dict and set, as part of its built-in types. The standard
library provides powerful and well tested versions of other structures

The enum module defines an enumeration type with iteration and comparison
capabilities. It can be used to create well-defined symbols for values,
instead of using literal integers or strings

A new enumeration is defined using the class syntax by subclassing
Enum and adding class attributes describing the values.
"""
import enum


class BugStatus(enum.Enum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


def main():
    print(f"\nMember name: {BugStatus.wont_fix.name}")
    print(f"Member value: {BugStatus.wont_fix.value}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Iterate}
\begin{lstlisting}[language=Python]
"""
Listing 2.2

Iterating over the enum class produces the individual members of the
enumeration

The members are produced in the order they are declared in the class
definition. The names and values are not used to sort them in any
way
"""
import enum


class BugStatus(enum.Enum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


def main():
    for status in BugStatus:
        print(f"{status.name:15} = {status.value}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Comparison}
\begin{lstlisting}[language=Python]
"""
Listing 2.3

Because enumeration members are not ordered, they only support comparison
by identity and equality
"""
import enum


class BugStatus(enum.Enum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


def main():
    actual_state = BugStatus.wont_fix
    desired_state = BugStatus.fix_released

    print("Equality:",
          actual_state == desired_state,
          actual_state == BugStatus.wont_fix
          )

    print("Identity:",
          actual_state is desired_state,
          actual_state is BugStatus.wont_fix
          )

    try:
        print("\n".join(" " + s.name for s in sorted(BugStatus)))
    except TypeError as err:
        print(f"  Cannot sort(): {err}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Intenum}
\begin{lstlisting}[language=Python]
"""
Listing 2.4

Use the IntEnum class for enumerations where the members need to behave
more like numbers e.g. to support comparisons
"""
import enum


class BugStatus(enum.IntEnum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


def main():
    print("Ordered by value:")
    print("\n".join("  " + s.name for s in sorted(BugStatus)))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Aliases}
\begin{lstlisting}[language=Python]
"""
Listing 2.5

Enum members with the same value are tracked as alias references to the
same member object. Aliases do not cause repeated values to be present in
the iterator for the Enum
"""
import enum


class BugStatus(enum.Enum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1

    by_design = 4
    closed = 1


def main():
    for status in BugStatus:
        print(f"{status.name:15} = {status.value}")

    print(f"\nSame: by_design is wont_fix",
          BugStatus.by_design is BugStatus.wont_fix)
    print(f"Same: closed is fix_released",
          BugStatus.closed is BugStatus.fix_released)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Unique Enforce}
\begin{lstlisting}[language=Python]
"""
Listing 2.6

To require all members to have unique values, add the @unique
decorator to the Enum
"""
import enum


@enum.unique
class BugStatus(enum.Enum):
    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1

    by_design = 4
    closed = 1


def main():
    for status in BugStatus:
        print(f"{status.name:15} = {status.value}")

    print(f"\nSame: by_design is wont_fix",
          BugStatus.by_design is BugStatus.wont_fix)
    print(f"Same: closed is fix_released",
          BugStatus.closed is BugStatus.fix_released)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Programmatic Create}
\begin{lstlisting}[language=Python]
"""
Listing 2.7

In some cases, it is more convenient to create enumerations programmatically,
rather than hard-coding them in a class definition. For those situations,
Enum also supports passing the member names and values to the class
constructor.

The value argument is the name of the enumeration, which is used to
build the representation of members. The names argument lists the
members of the enumeration. When a single string is passed, it is
split on whitespace and commas, and the resulting tokens are used as
names for the members, which are automatically assigned values
starting with 1
"""
import enum


def main():
    BugStatus = enum.Enum(
        value="BugStatus",
        names=("fix_released fix_committed in_progress "
               "wont_fix invalid incomplete new")
    )

    print(f"Member: {BugStatus.new}")
    print("\nAll members:")
    for status in BugStatus:
        print(f"{status.name:15} = {status.value}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Programmatic Mapping}
\begin{lstlisting}[language=Python]
"""
Listing 2.8

For more control over the values associated with members, the names string
can be replaced with a sequence of two-part tuples or a dictionary
mapping names to values.
"""
import enum


def main():
    BugStatus = enum.Enum(
        value="BugStatus",
        names=[
            ("new", 7),
            ("incomplete", 6),
            ("invalid", 5),
            ("wont_fix", 4),
            ("in_progress", 3),
            ("fix_committed", 2),
            ("fix_released", 1)
        ]
    )

    print("All members:")
    for status in BugStatus:
        print(f"{status.name:15} = {status.value}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Tuple Values}
\begin{lstlisting}[language=Python]
"""
Listing 2.9

Enum member values are not restricted to integers. In fact, any type of
object can be associated with a member. If the value is a tuple, the
members are passed as individual arguments to __init__
"""
import enum


class BugStatus(enum.Enum):
    new = (7, ["incomplete", "invalid", "wont_fix", "in_progress"])
    incomplete = (6, ["new", "wont_fix"])
    invalid = (5, ["new"])
    wont_fix = (4, ["new"])
    in_progress = (3, ["new", "fix_committed"])
    fix_committed = (2, ["in_progress", "fix_released"])
    fix_released = (1, ["new"])

    def __init__(self, num, transitions):
        self.num = num
        self.transitions = transitions

    def can_transition(self, new_state):
        return new_state.name in self.transitions


def main():
    print("Name:", BugStatus.in_progress)
    print("Value:", BugStatus.in_progress.value)
    print("Custom attribute:", BugStatus.in_progress.transitions)
    print("Using attribute:",
          BugStatus.in_progress.can_transition(BugStatus.new))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Enum Complex Values}
\begin{lstlisting}[language=Python]
"""
Listing 2.10

For more complex cases, tuples might become unwieldy. Since member
values can be any type of object, dictionaries can be used for cases
where there are a lot of separate attributes to track for each enum
value.

Complex values are passed directly to __init__() as the only argument
other than self
"""
import enum


class BugStatus(enum.Enum):

    new = {
        "num": 7,
        "transitions": [
            "incomplete",
            "invalid",
            "wont_fix",
            "in_progress"
        ]
    }

    incomplete = {
        "num": 6,
        "transitions": [
            "new",
            "wont_fix"
        ]
    }

    invalid = {
        "num": 5,
        "transitions": [
            "new"
        ]
    }

    wont_fix = {
        "num": 4,
        "transitions": [
            "new"
        ]
    }

    in_progress = {
        "num": 3,
        "transitions": [
            "new",
            "fix_committed"
        ]
    }

    fix_committed = {
        "num": 2,
        "transitions": [
            "in_progress",
            "fix_released"
        ]
    }

    fix_released = {
        "num": 1,
        "transitions": [
            "new"
        ]
    }

    def __init__(self, vals):
        self.num = vals["num"]
        self.transitions = vals["transitions"]

    def can_transition(self, new_state):
        return new_state.name in self.transitions


def main():
    print("Name:", BugStatus.in_progress)
    print("Value:", BugStatus.in_progress.value)
    print("Custom attribute:", BugStatus.in_progress.transitions)
    print("Using attribute:",
          BugStatus.in_progress.can_transition(BugStatus.new))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap Read}
\begin{lstlisting}[language=Python]
"""
Listing 2.11

The collections module includes container data types beyond the built-in
types list, dict and tuple.

The ChainMap class manages a sequence of dictionaries, and searches
through them in the order that they appear to find values associated with
keys.

A ChainMap makes a good "context" container, since it can be treated as
a stack for which changes happen as the stack grows, with these
changes being discarded again as the stack shrinks.

The ChainMap supports the same API as a regular dictionary for accessing
existing values
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}

    m = collections.ChainMap(a, b)
    print("Individual Values")
    print(f"a = {m['a']}")
    print(f"b = {m['b']}")
    print(f"c = {m['c']}")

    print(f"Keys = {list(m.keys())}")
    print(f"Values = {list(m.values())}")

    print("Items:")
    for k, v in m.items():
        print(f"{k} = {v}")
    print()

    print(f"'d' in m: {'d' in m}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap Reorder}
\begin{lstlisting}[language=Python]
"""
Listing 2.12

The ChainMap stores the list of mappings over which it searches in a list
in its maps attribute. This list is mutable, so it is possible to add new
mappings directly or to change the order of the elements to control
lookup and update behaviour
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}

    m = collections.ChainMap(a, b)

    print(m.maps)
    print(f"c = {m['c']}")

    # Reverse the list
    m.maps = list(reversed(m.maps))

    print(m.maps)
    print(f"c = {m['c']}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap Update Behind}
\begin{lstlisting}[language=Python]
"""
Listing 2.13

A ChainMap does not cache the values in the child mappings. Thus, if their
contents are modified, the results are reflected when the ChainMap is
accessed.
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}

    m = collections.ChainMap(a, b)

    print(f"Before: {m['c']}")
    a["c"] = "E"
    print(f"After: {m['c']}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap Update Directly}
\begin{lstlisting}[language=Python]
"""
Listing 2.14

It is also possible to set values through the ChainMap directly,
although only the first mapping in the chain is actually modified

When the new value is stored using m, the a mapping is updated
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}

    m = collections.ChainMap(a, b)

    print("Before:", m)
    m["c"] = "E"
    print("After:", m)
    print("a:", a)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap New Child}
\begin{lstlisting}[language=Python]
"""
Listing 2.15

ChainMap provides a convenience method for creating a new instance with
one extra mapping at the front of the maps list to make it easy to avoid
modifying the existing underlying data structures

This stacking behaviour is what makes it convenient to use ChainMap
instances as template or application contexts. Specifically, it is
easy to add or update values in one iteration, then discard the changes
for the next iteration
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}

    m1 = collections.ChainMap(a, b)
    m2 = m1.new_child()

    print("m1 before:", m1)
    print("m2 before:", m2)

    m2["c"] = "E"

    print("m1 after:", m1)
    print("m2 after:", m2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Chainmap New Child Explicit}
\begin{lstlisting}[language=Python]
"""
Listing 2.16

For situations where the new context is known or built in advance, it is
also possible to pass a mapping to new_child()

This is the equivalent of
    m2 = collections.ChainMap(c, *m1.maps)
"""
import collections


def main():
    a = {"a": "A", "c": "C"}
    b = {"b": "B", "c": "D"}
    c = {"c": "E"}

    m1 = collections.ChainMap(a, b)
    m2 = m1.new_child(c)

    print(f"m1['c'] = {m1['c']}")
    print(f"m2['c'] = {m2['c']}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Init}
\begin{lstlisting}[language=Python]
"""
Listing 2.17

A Counter is a container that keeps track of how many times equivalent
values are added. It can be used to implement the same algorithms for
which other languages commonly use bag or multiset data structures

Counter supports three forms of initialization. Its constructor can be
called with a sequence of items, a dictionary containing keys and counts
or using keyword arguments that map string names to counts
"""
import collections


def main():
    print(collections.Counter(["a", "b", "c", "a", "b", "b"]))
    print(collections.Counter({"a": 2, "b": 3, "c": 1}))
    print(collections.Counter(a=2, b=3, c=1))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Update}
\begin{lstlisting}[language=Python]
"""
Listing 2.18

An empty Counter can be constructed with no arguments and populated via
the update() method

The count values are increased based on the new data, rather than replaced
"""
import collections


def main():
    c = collections.Counter()
    print("Initial :", c)
    c.update("abcdaab")
    print("Sequence:", c)
    c.update({"a": 1, "d": 5})
    print("Dict    :", c)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Get Values}
\begin{lstlisting}[language=Python]
"""
Listing 2.19

Once a Counter is populated, its values can be retrieved using the
dictionary API

Counter does not raise KeyError for unknown items. If a value has not
been seen in the input, its count is 0
"""
import collections


def main():
    c = collections.Counter("abcdaab")

    for letter in "abcde":
        print(f"{letter} : {c[letter]}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Elements}
\begin{lstlisting}[language=Python]
"""
Listing 2.20

The elements() method returns an iterator that produces all of the items
known to the Counter

The order of elements is not guaranteed and items with counts less than
or equal to zero are not included
"""
import collections


def main():
    c = collections.Counter("extremely")
    c["z"] = 0
    print(c)
    print(list(c.elements()))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Most Common}
\begin{lstlisting}[language=Python]
"""
Listing 2.21

Use most_common() to produce a sequence of the n most frequently
encountered input values and their respective counts
"""
import collections


def main():
    c = collections.Counter()
    with open("/usr/share/dict/words", "rt") as f:
        for line in f:
            c.update(line.rstrip().lower())

    print("Most common:")
    for letter, count in c.most_common():
        print(f"{letter}: {count:>7}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Counter Arithmetic}
\begin{lstlisting}[language=Python]
"""
Listing 2.22

Counter instances support arithmetic and set operations for aggregating
results. This example shows the standard operators for creating new
Counter instances, bu the in-place operators +=, -=, &= and |=
are also supported

Each time a new Counter is produced through an operation, any items
with zero or negative counts are discarded.
"""
import collections


def main():
    c1 = collections.Counter(["a", "b", "c", "a", "b", "b"])
    c2 = collections.Counter("alphabet")

    print("C1:", c1)
    print("C2:", c2)

    print("\nCombined counts:")
    print(c1 + c2)

    print("\nSubtraction:")
    print(c1 - c2)

    print("\nIntersection (taking positive minimums):")
    print(c1 & c2)

    print("\nUnion (taking maximums):")
    print(c1 | c2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Default Dict}
\begin{lstlisting}[language=Python]
"""
Listing 2.23

The standard dictionary includes the method setdefault() for retrieving
a value and establishing a default if the value does not exist.
By contrast, defaultdict lets the caller specify the default up
front when the container is initialized

This method works well as long as it is appropriate for all keys to
have the same default. It can be especially useful if the default
is a type used for aggregating or accumulating values, such as a
list, set or even int.
"""
import collections


def default_factory():
    return "default value"


def main():
    d = collections.defaultdict(default_factory, foo="bar")
    print("d:", d)
    print("foo =>", d["foo"])
    print("bar =>", d["bar"])


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Deque}
\begin{lstlisting}[language=Python]
"""
Listing 2.24

A double-ended queue or deque supports adding and removing elements from
either end of the queue. The more commonly used stacks and queues are
degenerate forms of deques where the inputs and outputs are restricted
to a single end

Since deques are a type of sequence container, they support some of
the same operations as list, such as examining the contents with
__getitem__(), determining the length and removing elements from
the middle of the queue by matching identity
"""
import collections


def main():
    d = collections.deque("abcdefg")
    print("Deque:", d)
    print("Length:", len(d))
    print("Left end:", d[0])
    print("Right end:", d[-1])

    d.remove("c")
    print("remove(c):", d)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Deque Populating}
\begin{lstlisting}[language=Python]
"""
Listing 2.25

A deque can be populated from either end, termed "left" and "right" in
the Python implementation

The extendleft() function iterates over its input and performs the
equivalent of an appendleft() for each item. The end result is that
deque contains the input sequence in reverse order
"""
import collections


def main():
    # Add to the right.
    d1 = collections.deque()
    d1.extend("abcdefg")
    print("extend    :", d1)
    d1.append("h")
    print("append    :", d1)

    # Add to the left
    d2 = collections.deque()
    d2.extendleft(range(6))
    print("extendleft:", d2)
    d2.appendleft(6)
    print("appendleft:", d2)


if __name__ == "__main__":
    main()


\end{lstlisting}
\section{Collections Deque Consuming}
\begin{lstlisting}[language=Python]
"""
Listing 2.26

The elements of the deque can be consumed from both ends or either end,
depending on the algorithm being applied

Use pop() to remove an item from the "right" end of the deque and
popleft() to take an item from the "left" end
"""
import collections


def main():
    print("From the right:")
    d = collections.deque("abcdefg")
    while True:
        try:
            print(d.pop(), end="")
        except IndexError:
            break
    print()

    print("\nFrom the left:")
    d = collections.deque(range(6))
    while True:
        try:
            print(d.popleft(), end="")
        except IndexError:
            break
    print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Deque Both Ends}
\begin{lstlisting}[language=Python]
"""
Listing 2.27

Since deques are thread-safe, the contents can even be consumed from both
ends at the same time from separate threads
"""
import collections
import threading
import time


def burn(direction, nextSource):
    while True:
        try:
            next = nextSource()
        except IndexError:
            break
        else:
            print(f"{direction:>8}: {next}")
            time.sleep(1)
    print(f"{direction:>8} done")


def main():
    candle = collections.deque(range(10))
    left = threading.Thread(target=burn,
                            args=("Left", candle.popleft))
    right = threading.Thread(target=burn,
                            args=("Right", candle.pop))

    left.start()
    right.start()

    left.join()
    right.join()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Deque Rotate}
\begin{lstlisting}[language=Python]
"""
Listing 2.28

Another useful aspect of the deque is the ability to rotate it in either
direction, so as to skip over some items

Rotating the deque to the right (using a positive rotation) takes items
from the right and moves them to the left end. Rotating to the left
(with a negative value) takes items from the left end and moves them to
the right end.
"""
import collections


def main():
    d = collections.deque(range(10))
    print("Normal        :", d)

    d = collections.deque(range(10))
    d.rotate(2)
    print("Right rotation:", d)

    d = collections.deque(range(10))
    d.rotate(-2)
    print("Left rotation :", d)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Deque Maxlen}
\begin{lstlisting}[language=Python]
"""
Listing 2.29

A deque instance cna be configured with a maximum length so that it never
grows beyond that size. When the queue reaches the specified length,
existing items are discarded as new items are added. This behaviour is
useful for finding the last n items in a stream of undetermined length

The deque length is maintained regardless of which end the items are
added to.
"""
import collections
import random


def main():
    # Set the random seed so we see the same output each time
    # the script is run.
    random.seed(1)

    d1 = collections.deque(maxlen=3)
    d2 = collections.deque(maxlen=3)

    for i in range(5):
        n = random.randint(0, 100)
        print("n = ", n)
        d1.append(n)
        d2.appendleft(n)
        print("D1:", d1)
        print("D2:", d2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Tuple}
\begin{lstlisting}[language=Python]
"""
Listing 2.30

The standard tuple uses numerical indexes to access its members. This
makes tuples convenient containers for simple uses.
"""


def main():
    bob = ("Bob", 30, "male")
    print("Representation:", bob)

    jane = ("Jane", 29, "female")
    print("\nField by index:", jane[0])

    print("\nFields by index:")
    for p in [bob, jane]:
        print(f"{p[0]} is a {p[1]} year old {p[2]}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Person}
\begin{lstlisting}[language=Python]
"""
Listing 2.31

In contrast, remembering which index should be used for each value can
lead to errors, especially if the tuple has a lot of fields and is
constructed far from where it is used. A namedtuple assigns names,
as well as the numerical index, to each member.

namedtuple instances are just as memory efficient as regular tuples because
they do not have per-instance dictionaries. Each kind of namedtuple is
represented by its own class, which is created by using the namedtuple()
factory function. The arguments are the name of the new class and a
string containing the names of the elements

It is possible to access the fields of the namedtuple by name using
dotted notation (obj.attr) as well as by using the position indexes of
standard tuples
"""
import collections


def main():
    Person = collections.namedtuple("Person", "name age")

    bob = Person(name="Bob", age=30)
    print("\nRepresentation:", bob)

    jane = Person(name="Jane", age=29)
    print("\nField by name", jane.name)

    print("\nFields by index:")
    for p in [bob, jane]:
        print(f"{p[0]} is {p[1]} years old")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Immutable}
\begin{lstlisting}[language=Python]
"""
Listing 2.32

Just like a regular tuple, a namedtuple is immutable. This restriction
allows tuple instances to have a consistent hash value, which makes it
possible to use them as keys in dictionaries and to be included in
sets.

Trying to change a value through its named attribute results in an
AttributeError
"""
import collections


def main():
    Person = collections.namedtuple("Person", "name age")

    pat = Person(name="Pat", age=12)
    print("\nRepresentation:", pat)
    pat.age = 21  # AttributeError


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Bad Fields}
\begin{lstlisting}[language=Python]
"""
Listing 2.33

Field names are invalid if they are repeated or conflict with Python
keywords
"""
import collections


def main():
    try:
        collections.namedtuple("Person", "name class age")
    except ValueError as err:
        print(err)

    try:
        collections.namedtuple("Person", "name age age")
    except ValueError as err:
        print(err)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Rename}
\begin{lstlisting}[language=Python]
"""
Listing 2.34

In situations where a namedtuple is created based on values outside the
control of the program, the rename option should be set to True so that
the invalid fields are renamed

The new names for the renamed fields depend on their index in the tuple
"""
import collections


def main():
    with_class = collections.namedtuple(
        "Person", "name class age",
        rename=True
    )
    print(with_class._fields)

    two_ages = collections.namedtuple(
        "Person", "name age age",
        rename=True
    )
    print(two_ages._fields)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Fields}
\begin{lstlisting}[language=Python]
"""
Listing 2.35

namedtuple provides several useful attributes and methods for working
with subclasses and instances. All of these built-in properties have names
prefixed with an underscore, which protects from name collision with
the user provided attribute names

The names of the fields passed to namedtuple to define the new class
are saved in the _fields attribute.
"""
import collections


def main():
    Person = collections.namedtuple("Person", "name age")
    bob = Person(name="Bob", age=30)
    print("Representation:", bob)
    print("Fields:", bob._fields)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Asdict}
\begin{lstlisting}[language=Python]
"""
Listing 2.36

namedtuple instances can be converted to OrderedDict instances using
_asdict()
"""
import collections


def main():
    Person = collections.namedtuple("Person", "name age")
    bob = Person(name="Bob", age=30)
    print("Representation:", bob)
    print("As Dictionary:", bob._asdict())


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Namedtuple Replace}
\begin{lstlisting}[language=Python]
"""
Listing 2.37

The _replace() method builds a new instance, replacing the values of
some fields in the process

Although the name implies it is modifying the existing object, because
namedtuple instances are immutable, the method actually returns a
new object
"""
import collections


def main():
    Person = collections.namedtuple("Person", "name age")

    bob = Person(name="Bob", age=30)
    print("\nBefore:", bob)
    bob2 = bob._replace(name="Robert")
    print("After:", bob2)
    print("Same?:", bob is bob2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Ordereddict Iter}
\begin{lstlisting}[language=Python]
"""
Listing 2.38

An OrderedDict is a dictionary subclass that remembers the order in which
its contents are added

A regular dict does not track the insertion order and iterating over it
produces the values in order based on how the keys are stored in the
hash table.

OrderedDict, by contrast, remembers the order of items inserted and
uses it when creating an iterator

** from 3.7, insertion order for python dictionaries is guaranteed
"""
import collections


def main():
    print("Regular dictionary:")
    d = {}
    d["a"] = "A"
    d["b"] = "B"
    d["c"] = "C"

    for k, v in d.items():
        print(k, v)

    print("OrderedDict:")
    d = collections.OrderedDict()
    d["a"] = "A"
    d["b"] = "B"
    d["c"] = "C"

    for k, v in d.items():
        print(k, v)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Ordereddict Equality}
\begin{lstlisting}[language=Python]
"""
Listing 2.39

A regular dict looks at its contents when testing for equality. An
OrderedDict also considered the order in which the items were added

In this case, since two ordered dictionaries are created from values
in a different order, they are considered to be different
"""
import collections


def main():
    print("dict       :", end=" ")
    d1 = {}
    d1["a"] = "A"
    d1["b"] = "B"
    d1["c"] = "C"

    d2 = {}
    d2["c"] = "C"
    d2["b"] = "B"
    d2["a"] = "A"

    print(d1 == d2)

    print("OrderedDict:", end=" ")

    d1 = collections.OrderedDict()
    d1["a"] = "A"
    d1["b"] = "B"
    d1["c"] = "C"

    d2 = collections.OrderedDict()
    d2["c"] = "C"
    d2["b"] = "B"
    d2["a"] = "A"

    print(d1 == d2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Collections Ordereddict Move To End}
\begin{lstlisting}[language=Python]
"""
Listing 2.40

It is possible to change the order of the keys in an OrderedDict by
moving them to either the beginning or the end of the sequence using
move_to_end()

The last argument tells move_to_end() whether to move the item to be
the last item in the key sequence (when True) or the first (when False)
"""
import collections


def main():
    d = collections.OrderedDict(
        [("a", "A"), ("b", "B"), ("c", "C")]
    )
    print("Before:")
    for k, v in d.items():
        print(k, v)

    d.move_to_end("b")

    print("\nmove_to_end():")
    for k, v in d.items():
        print(k, v)

    d.move_to_end("b", last=False)
    print("\nmove_to_end(last=False):")
    for k, v in d.items():
        print(k, v)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Array String}
\begin{lstlisting}[language=Python]
"""
Listing 2.41

The array module defines a sequence data structure that looks very much
like a list, except that all of the members have to be of the same
primitive type.

The types supported are all numeric or other fixed-size primitive types
such as bytes

Code        Type                Minimum Size (Bytes)
b           Int                 1
B           Int                 1
h           Signed short        1
H           Unsigned short      1
i           Signed int          1
I           Unsigned int        1
l           Signed long         1
L           Unsigned long       1
q           Signed long long    1
Q           Unsigned long long  1
f           Float               1
d           Double float        1

An array is instantiated with an argument describing the type of data
to be allowed, and possibly an initial sequence of data to store
in the array
"""
import array
import binascii


def main():
    s = b"This is the array"
    a = array.array("b", s)

    print("As byte string:", s)
    print("As array      :", a)
    print("As hex        :", binascii.hexlify(a))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Array Sequence}
\begin{lstlisting}[language=Python]
"""
Listing 2.42

An array can be extended and otherwise manipulated in the same ways
as other Python sequences
"""
import array
import pprint


def main():
    a = array.array("i", range(3))
    print("Initial :", a)

    a.extend(range(3))
    print("Extended:", a)

    print("Slice   :", a[2:5])

    print("Iterator:")
    print(list(enumerate(a)))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Array File}
\begin{lstlisting}[language=Python]
"""
Listing 2.43

The contents of an array can be written to and read from files using
built-in methods coded efficiently for that purpose
"""
import array
import binascii
import tempfile


def main():
    a = array.array("i", range(5))
    print("A1:", a)

    # Write the array of numbers to a temporary file
    output = tempfile.NamedTemporaryFile()
    a.tofile(output.file)  # Must pass an *actual* file
    output.flush()

    # Read the raw data
    with open(output.name, "rb") as input:
        raw_data = input.read()
        print("Raw Contents:", binascii.hexlify(raw_data))

        # Read the data into an array
        input.seek(0)
        a2 = array.array("i")
        a2.fromfile(input, len(a))
        print("A2:", a2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Array Tobytes}
\begin{lstlisting}[language=Python]
"""
Listing 2.44

tofile() uses tobytes() to format the data, and fromfile() uses
frombytes() to convert it back to an array instance
"""
import array
import binascii


def main():
    a = array.array("i", range(5))
    print("A1:", a)

    as_bytes = a.tobytes()
    print("Bytes:", binascii.hexlify(as_bytes))

    a2 = array.array("i")
    a2.frombytes(as_bytes)
    print("A2:", a2)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Array Byteswap}
\begin{lstlisting}[language=Python]
"""
Listing 2.45

If the data in the array is not in the native byte order, or if the
data needs to be swapped before being sent to a system with a different
byte order (or over the network), it is possible to convert the entire
array without iterating over the elements from Python.

The byteswap() method switches the byte order of the items in the array
from within C, so it is much more efficient than looping over data in
Python
"""
import array
import binascii


def to_hex(a):
    chars_per_item = a.itemsize * 2  # 2 hex digits
    hex_version = binascii.hexlify(a)
    num_chunks = len(hex_version)  // chars_per_item
    for i in range(num_chunks):
        start = i * chars_per_item
        end = start + chars_per_item
        yield hex_version[start:end]


def main():
    start = int("0x12345678", 16)
    end = start + 5

    a1 = array.array("i", range(start, end))
    a2 = array.array("i", range(start, end))
    a2.byteswap()

    print(f"{'A1 hex':>12} {'A1':>12} {'A2 hex':>12} {'A2':>12}")
    print(f"{'-' * 12} {'-' * 12} {'-' * 12} {'-' * 12}")

    fmt = "{!r:>12} {:12} {!r:>12} {:12}"
    for values in zip(to_hex(a1), a1, to_hex(a2), a2):
        print(fmt.format(*values))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Heappush}
\begin{lstlisting}[language=Python]
"""
Listing 2.48

There are two basic ways to create a heap: heappush() and heapify()
"""
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data


def main():
    heap = []
    print("random :", data)
    print()

    for n in data:
        print(f"add {n:3}")
        heapq.heappush(heap, n)
        show_tree(heap)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Heapify}
\begin{lstlisting}[language=Python]
"""
Listing 2.49

If the data is already in memory, it is more efficient to use heapify
to rearrange the items of the list in place

The result of building a list in heap order one item at a time is
the same as building an underordered list and then calling heapify()
"""
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data


def main():
    print("random    :", data)
    heapq.heapify(data)
    print("heapified :")
    show_tree(data)
    print(data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Heappop}
\begin{lstlisting}[language=Python]
"""
Listing 2.50

Once the heap is organized correctly, use heappop() to remove the element
with the lowest value
"""
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data


def main():
    print("random    :", data)
    heapq.heapify(data)
    print("heapified :")
    show_tree(data)
    print

    for i in range(2):
        smallest = heapq.heappop(data)
        print(f"pop    {smallest:>3}:")
        show_tree(data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Heapreplace}
\begin{lstlisting}[language=Python]
"""
Listing 2.50

To remove existing elements and replace them with new values in a
single operation, use heapreplace()

Replacing elements in place makes it possible to maintain a fixed-size
heap, such as a queue of jobs ordered by priority
"""
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data


def main():
    heapq.heapify(data)
    print("start ")
    show_tree(data)

    for n in [0, 13]:
        smallest = heapq.heapreplace(data, n)
        print(f"replace {smallest:>2} with {n:>2}:")
        show_tree(data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Extremes}
\begin{lstlisting}[language=Python]
"""
Listing 2.52

heapq also includes two functions to examine an iterable and find a range
of the largest or smallest values it contains

Using nlargest() and nsmallest() is efficient only for relatively small
values of n > 1, but can still come in handy in a few cases
"""
import heapq
from heapq_heapdata import data


def main():
    print("all       :", data)
    print("3 largest :", heapq.nlargest(3, data))
    print("from sort :", list(reversed(sorted(data)[-3:])))
    print("3 smallest:", heapq.nsmallest(3, data))
    print("from sort :", sorted(data)[:3])


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Heapq Merge}
\begin{lstlisting}[language=Python]
"""
Listing 2.53

Combining several sorted sequences into one new sequence is easy for
small data sets
    list(sorted(itertoool.chain(*data)))

For larger data sets, this technique can use a considerable amount of
memory. Instead of sorting the entire combined sequence, merge()
uses a heap to generate a new sequence one item at a time, determining
the next item using a fixed amount of memory

Because the implementation of merge uses a heap, it consumes memory based
on the number of sequences being merged, rather than the number of
items in those sequences
"""
import heapq
import random


def main():
    random.seed(2016)

    data = []
    for i in range(4):
        new_data = list(random.sample(range(1, 101), 5))
        new_data.sort()
        data.append(new_data)

    for i, d in enumerate(data):
        print(f"{i}: {d}")

    print("\nMerged:")
    for i in heapq.merge(*data):
        print(i, end=" ")
    print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Bisect Example}
\begin{lstlisting}[language=Python]
"""
Listing 2.54

The bisect module implements an algorithm for inserting elements
into a list while maintaining the list in sorted order

insort() is used to insert items into a list in sorted order

For long lists, significant time and memory savings can be achieved
using an insertion sort algorithm such as this, especially when
the operation to compare two members of the list requires expensive
computation
"""
import bisect


def main():
    values = [14, 85, 77, 26, 50, 45, 66, 79, 10, 3, 84, 77, 1]

    print("New  Pos Contents")
    print("___  ___ ________")

    l = []

    for i in values:
        position = bisect.bisect(l, i)
        bisect.insort(l, i)
        print(f"{i:3}  {position:3} {l}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Bisect Example2}
\begin{lstlisting}[language=Python]
"""
Listing 2.55

The bisect module provides two ways to handle repeats. New values
can be inserted either to the left of existing values, or to the
right. The insort() function is actually an alias for insort_right()
which inserts an item after the existing value
The corresponding function insort_left inserts an item before the
existing value
"""
import bisect


def main():
    values = [14, 85, 77, 26, 50, 45, 66, 79, 10, 3, 84, 77, 1]

    print("New  Pos Contents")
    print("___  ___ ________")

    l = []

    for i in values:
        position = bisect.bisect_left(l, i)
        bisect.insort_left(l, i)
        print(f"{i:3}  {position:3} {l}")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Queue Fifo}
\begin{lstlisting}[language=Python]
"""
Listing 2.56

The queue module provides a first-in, first-out data structure suitable
for multi-threaded programming. It can be used to pass messages or other
data between producer and consumer threads safely. Locking is handled for
the caller, so many threads can work with the same Queue instance safely
and easily. The size of a Queue (the number of elements it contains) may
be restricted to throttle memory usage or processing

The Queue class implements a basic first-in, first-out container.
Elements are added to one "end" of the sequence using put(), and
removed from the other end using get()

Elements are removed from the queue in the same order in which they
are inserted
"""
import queue


def main():
    q = queue.Queue()

    for i in range(5):
        q.put(i)

    while not q.empty():
        print(q.get(), end=" ")
    print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Queue Lifo}
\begin{lstlisting}[language=Python]
"""
Listing 5.7

In contrast to the standard FIFO implementation of Queue, the
LifoQueue uses last-in, first-out orderings (normally associated with
a stack data structure)
"""
import queue


def main():
    q = queue.LifoQueue()

    for i in range(5):
        q.put(i)

    while not q.empty():
        print(q.get(), end=" ")
    print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Queue Priority}
\begin{lstlisting}[language=Python]
"""
Listing 2.58

Sometimes the processing order of the items in a queue needs to be based
on characteristics of those items, rather than just the order they are
created or added to the queue. PriorityQueue uses the sort order of the
contents of the queue to decide which item to retrieve
"""
import functools
import queue
import threading

@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        print("New job:", description)
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented


def process_job(q):
    while True:
        next_job = q.get()
        print("Processing job: ", next_job.description)
        q.task_done()


def main():
    q = queue.PriorityQueue()

    q.put(Job(3, "Mid-level job"))
    q.put(Job(10, "Low-level job"))
    q.put(Job(1, "Important job"))

    workers = [
        threading.Thread(target=process_job, args=(q,)),
        threading.Thread(target=process_job, args=(q,))
    ]

    for w in workers:
        w.setDaemon(True)
        w.start()

    q.join()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Fetch Podcasts}
\begin{lstlisting}[language=Python]
"""
Listing 2.59

This example demonstrates how to use the Queue class with multiple
threads. The program reads one or more RSS feeds, queues up the
enclosures for the five most recent episodes from each feed to be downloaded,
and processes sever downloads in parallel using threads.

* conda install feedparser
"""
import queue
import threading
import time
import urllib
import urllib.parse

import feedparser

# Set up some global variables
num_fetch_threads = 2
enclosure_queue = queue.Queue()
feed_urls = [
    "http://talkpython.fm/episodes/rss"
]


def message(s):
    print(f"{threading.current_thread().name}: {s}")


def download_enclosures(q):
    """
    This is the worker thread function.
    It processes items in the queue one after
    another. These daemon threads go into an
    infinite loop and exit only when the main
    thread ends
    :param q:
    :return:
    """
    while True:
        message("look for for the next enclosure")
        url = q.get()
        filename = url.rpartition("/")[-1]
        message(f"downloading {filename}")
        response = urllib.request.urlopen(url)
        data = response.read()
        message(f"writing to {filename}")
        with open(filename, "wb") as outfile:
            outfile.write(data)
        q.task_done()


def main():
    for i in range(num_fetch_threads):
        worker = threading.Thread(
            target=download_enclosures,
            args=(enclosure_queue,),
            name=f"worker-{i}"
        )
        worker.setDaemon(True)
        worker.start()

    # Download the feed(s) and put the enclosure URLs into
    # the queue
    for url in feed_urls:
        response = feedparser.parse(url, agent="fetch_podcasts.py")
        for entry in response["entries"][:5]:
            for enclosure in entry.get("enclosures", []):
                parsed_url = urllib.parse.urlparse(enclosure["url"])
                message(f"queueing {parsed_url.path.rpartition('/')[-1]}")
                enclosure_queue.put(enclosure["url"])

    message("*** main thread waiting")
    enclosure_queue.join()
    message("*** done")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Struct Pack}
\begin{lstlisting}[language=Python]
"""
Listing 2.60

The struct module includes functions for converting between strings
of bytes and native Python data types such as numbers and strings.

A set of module-level functions is available for working with structured
values, as well as the Struct class. Format specifiers are converted from
their string format to a compiled representation, similar to the way
regular expressions are handles. The conversion takes some resources,
so it is typically more efficient to do it once when creating a Struct
instance and call methods on the instance, instead of using the module-
level functions.

Structs support packing data into strings, and upacking data from strings
using format specifiers made up of characters representing the type of
the data and optional count and endianness indicators.
"""
import struct
import binascii


def main():
    values = (1, "ab".encode("utf-8"), 2.7)
    s = struct.Struct("I 2s f")
    packed_data = s.pack(*values)

    print("Original values:", values)
    print("Format string  :", s.format)
    print("Uses           :", s.size, "bytes")
    print("Packed Value   :", binascii.hexlify(packed_data))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Struct Unpack}
\begin{lstlisting}[language=Python]
"""
Listing 2.61

Use unpack to extract data from its packed representation

Passing the packed value to unpack(), gives basically the same values
back.
"""
import struct
import binascii


def main():
    packed_data = binascii.unhexlify(b'0100000061620000cdcc2c40')

    s = struct.Struct("I 2s f")
    unpacked_data = s.unpack(packed_data)
    print("Unpacked Values:", unpacked_data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Struct Endianness}
\begin{lstlisting}[language=Python]
"""
Listing 2.62

By default, values are encoded using the native C library notion of
endianness. It is easy to override that choice by providing an explicit
endianness directive in the format string

    Code        Meaning
    @           Native oder
    =           Native standard
    <           Little-endian
    >           Big-endian
    !           Network order
"""
import struct
import binascii


def main():
    values = (1, "ab".encode("utf-8"), 2.7)
    print("Original values: ", values)

    endianness = [
        ("@", "native, native"),
        ("=", "native, standard"),
        ("<", "little-endian"),
        (">", "big-endian"),
        ("!", "network")
    ]

    for code, name in endianness:
        s = struct.Struct(code + " I 2s f")
        packed_data = s.pack(*values)
        print()
        print("Format string  :", s.format, "for", name)
        print("Uses           :", s.size, "bytes")
        print("Packed Value   :", binascii.hexlify(packed_data))
        print("Unpacked Value :", s.unpack(packed_data))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Struct Buffers}
\begin{lstlisting}[language=Python]
"""
Listing 2.63

Working with binary packed data is typically reserved for performance-
sensitive situations, or passing data into and out of extension modules.

These cases can be optimized by avoiding the overhead of allocating a
new buffer for each packed structure. The pack_into() and
unpack_from() methods support writing to pre-allocated buffers directly

The size attribute of the Struct tells us how big the buffer needs to be
"""
import array
import binascii
import ctypes
import struct


def main():
    s = struct.Struct("I 2s f")
    values = (1, "ab".encode("utf-8"), 2.7)
    print("Original:", values)
    print()

    print("ctypes string buffer")
    b = ctypes.create_string_buffer(s.size)
    print("Before  :", binascii.hexlify(b.raw))
    s.pack_into(b, 0, *values)
    print("After   :", binascii.hexlify(b.raw))
    print("Unpacked:", s.unpack_from(b, 0))

    print()
    print("array")

    a = array.array("b", b"\0" * s.size)
    print("Before  :", binascii.hexlify(a))
    s.pack_into(a, 0, *values)
    print("After   :", binascii.hexlify(a))
    print("Unpacked:", s.unpack_from(a, 0))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Ref}
\begin{lstlisting}[language=Python]
"""
Listing 2.64

The weakref module supports weak references to objects. A normal reference
increments the reference count on the object and prevents it from being
garbage collected.

This outcome is not always desirable, especially when a circular reference
might be present or when a cache of objects should be deleted when memory
is needed.

A weak reference is a handle to an object that does not keep it from
being cleaned up automatically

Weak references to objects are managed through the ref class. To
retrieve the original object, called the reference object
"""
import weakref


class ExpensiveObject:
    def __del__(self):
        print(f"(Deleting {self})")


def main():
    obj = ExpensiveObject()
    r = weakref.ref(obj)

    print("obj:", obj)
    print("ref:", r)
    print("r():", r())

    print("deleting obj")
    del obj
    print("r():", r())


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Ref Callback}
\begin{lstlisting}[language=Python]
"""
Listing 2.65

The ref constructor accepts an optional callback function that is invoked
when the referenced object is deleted
"""
import weakref


class ExpensiveObject:

    def __del__(self):
        print(f"(Deleting {self})")


def callback(reference):
    """Invoked when referenced object is deleted"""
    print(f"callback({reference!r})")


def main():
    obj = ExpensiveObject()
    r = weakref.ref(obj, callback)

    print("obj:", obj)
    print("ref:", r)
    print("r():", r())

    print("deleting obj")
    del obj
    print("r():", r())


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Finalize}
\begin{lstlisting}[language=Python]
"""
Listing 2.66

For more robust management of resources when weak references are cleaned
up, use finalize to associate callbacks with objects. A finalize instance
is retained until the attached object is deleted, even if the application
does not retain a reference to the finalizer

The arguments to finalize are the object to track, a callable to invoke
when the object is garbage collected, and any positional or named
arguments to pass to the callable
"""
import weakref


class ExpensiveObject:

    def __del__(self):
        print(f"(Deleting {self})")


def on_finalize(*args):
    print(f"on_finalize({args!r})")


def main():
    obj = ExpensiveObject()
    weakref.finalize(obj, on_finalize, "extra argument")

    del obj


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Finalize Atexit}
\begin{lstlisting}[language=Python]
"""
Listing 2.67

The finalize instance has a writable property atexist to control whether
the callback is invoked as a program is exiting, if it hasn't already
been called.
"""
import sys
import weakref


class ExpensiveObject:

    def __del__(self):
        print(f"(Deleting {self})")


def on_finalize(*args):
    print(f"on_finalize({args!r})")


def main():
    obj = ExpensiveObject()
    f = weakref.finalize(obj, on_finalize, "extra argument")
    f.atexit = bool(int(sys.argv[1]))

    del obj


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Finalize Reference}
\begin{lstlisting}[language=Python]
"""
Listing 2.68

Giving the finalize instance a reference to the object it tracks causes a
reference to be retained, so the object is never garbage collected
"""
import gc
import weakref


class ExpensiveObject:

    def __del__(self):
        print(f"(Deleting P{self})")


def on_finalize(*args):
    print(f"on finalize ({args!r})")


def main():
    obj = ExpensiveObject()
    obj_id = id(obj)

    f = weakref.finalize(obj, on_finalize, obj)
    f.atexit = False

    del obj

    for o in gc.get_objects():
        if id(o) == obj_id:
            print("found uncollected object in gc")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Finalize Reference Method}
\begin{lstlisting}[language=Python]
"""
Listing 2.69

Using a bound method of a tracked object as the callable can also prevent
an object from being finalized properly.

Because the callable given to finalize is a bound method of the instance
obj, the finalize object holds a reference to obj, which cannot be
deleted and garbage collected
"""
import gc
import weakref


class ExpensiveObject:
    def __del__(self):
        print(f"(Deleting {self})")

    def do_finalize(self):
        print("do_finalize")


def main():
    obj = ExpensiveObject()
    obj_id = id(obj)

    f = weakref.finalize(obj, obj.do_finalize)
    f.atexist = False

    del obj

    for o in gc.get_objects():
        if id(o) == obj_id:
            print("found uncollected object in gc")


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Proxy}
\begin{lstlisting}[language=Python]
"""
Listing 2.70

It is sometimes more convenient to use a proxy, rather than a weak
reference. Proxies can be used as though they were the original object
and do not need to be called before the object is accessible. As a
consequence, they can be passed to a library that does not know it is
receiving a reference instead of the real object
"""
import weakref


class ExpensiveObject:
    def __init__(self, name):
        self.name = name

    def __del__(self):
        print(f"(Deleting {self})")


def main():
    obj = ExpensiveObject("My Object")
    r = weakref.ref(obj)
    p = weakref.proxy(obj)

    print(f"via obj: {obj.name}")
    print(f"via ref: {r().name}")
    print(f"via proxy: {p.name}")
    del obj
    print(f"via proxy: {p.name}")  # ReferenceError


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Weakref Valuedict}
\begin{lstlisting}[language=Python]
"""
Listing 2.71

The ref and proxy classes are considered "low level". While they are
useful for maintaining weak references to individual objects and allowing
cycles to be garbage collected, the WeakKeyDictionary and
WeakValueDictionary classes provide a more appropriate API for creating
a cache of several objects

The WeakValueDictionary class uses weak references to the values it holds,
allowing them to be garbage collected when other code is not actually
using them. Using explicit calls to the garbage collector illustrates
the difference between memory handling with a regular dictionary
and a WeakValueDictionary

Any loop variables that refer to the values being cached must be
cleared explicitly so the reference count of the object is decremented.
Otherwise, the garbage collector will not remove the objects and
they will remain in the cache. Similarly, the all_refs variable
is used to hold references to prevent them from being garbage
collected prematurely.
"""
import gc
import pprint
import weakref

gc.set_debug(gc.DEBUG_UNCOLLECTABLE)


class ExpensiveObject:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"ExpensiveObject({self.name})"

    def __del__(self):
        print(f"    (Deleting {self})")


def demo(cache_factory):
    # Hold objects so any weak references
    # are not removed immediately
    all_refs = {}
    print("CACHE TYPE:", cache_factory)
    cache = cache_factory()
    for name in ["one", "two", "three"]:
        o = ExpensiveObject(name)
        cache[name] = o
        all_refs[name] = o
        del o  # decref

    print("   all_refs =", end=" ")
    pprint.pprint(all_refs)
    print("\n  Before, cache contains:", list(cache.keys()))
    for name, value in cache.items():
        print(f"    {name} = {value}")
        del value  # decref

    #Remove all references to the objects except the cache
    print("\n  Cleanup")
    del all_refs
    gc.collect()

    print("\n  After, cache contains:", list(cache.keys()))
    for name, value in cache.items():
        print(f"    {name} = {value}")
    print("  demo returning")
    return


def main():
    demo(dict)
    print()
    demo(weakref.WeakValueDictionary)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Copy Shallow}
\begin{lstlisting}[language=Python]
"""
Listing 2.72

The copy module includes two functions, copy() and deepcopy(), for
duplicating existing objects

The shallow copy created by copy() is a new container populated with
references to the contents of the original object. When making a shallow
copy of a list object, a new list is constructed and the elements of the
original list are appended to it

For a shallow copy, the MyClass instance is not duplicated, so the
reference in the dup list is to the same object that is in my_list
"""
import copy
import functools


@functools.total_ordering
class MyClass:

    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name


def main():
    a = MyClass("a")
    my_list = [a]
    dup = copy.copy(my_list)
    print("             my_list:", my_list)
    print("                 dup:", dup)
    print("      dup is my_list:", (dup is my_list))
    print("      dup == my_list:", (dup == my_list))
    print("dup[0] is my_list[0]:", (dup[0] is my_list[0]))
    print("dup[0] == my_list[0]:", (dup[0] == my_list[0]))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Copy Deep}
\begin{lstlisting}[language=Python]
"""
Listing 2.73

The deep copy created by deepcopy() is a new container populated with
copies of the contents of the original object. To make a deep copy
of a list, a new list is constructed, the elements of the original list
are copied, and then those copies are appended to the new list
"""
import copy
import functools


@functools.total_ordering
class MyClass:

    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name


def main():
    a = MyClass("a")
    my_list = [a]
    dup = copy.deepcopy(my_list)
    print("             my_list:", my_list)
    print("                 dup:", dup)
    print("      dup is my_list:", (dup is my_list))
    print("      dup == my_list:", (dup == my_list))
    print("dup[0] is my_list[0]:", (dup[0] is my_list[0]))
    print("dup[0] == my_list[0]:", (dup[0] == my_list[0]))


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Copy Hooks}
\begin{lstlisting}[language=Python]
"""
Listing 2.74

It is possible to control how copies are made using the __copy__()
and __deepcopy__() special methods

    __copy__() is called without any arguments and should return a
    shallow copy of the object

    __deepcopy__() is called with a memo dictionary and should return
    a deep copy of the object. Any member attributes that need to be
    deep-copied should be passed to copy.deepcopy(), along with the
    memo dictionary, to control for recursion

    The memo dictionary is used to keep track of the values that have
    been copied already, so as to avoid infinite recursion
"""
import copy
import functools


@functools.total_ordering
class MyClass:

    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name

    def __copy__(self):
        print("__copy__()")
        return MyClass(self.name)

    def __deepcopy__(self, memo):
        print(f"__deepcopy__({memo})")
        return MyClass(copy.deepcopy(self.name, memo))


def main():
    a = MyClass("a")
    sc = copy.copy(a)
    dc = copy.deepcopy(a)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Copy Recursion}
\begin{lstlisting}[language=Python]
"""
Listing 2.75

To avoid problems with duplicating recursive data structures, deepcopy()
uses a dictionary to track objects that have already been copied. The
dictionary is passed to the __deepcopy__() method so it can be examined
there as well
"""
import copy


class Graph:

    def __init__(self, name, connections):
        self.name = name
        self.connections = connections

    def add_connection(self, other):
        self.connections.append(other)

    def __repr__(self):
        return f"Graph(name={self.name}, id={id(self)})"

    def __deepcopy__(self, memo):
        print(f"\nCalling __deepcopy__ for {self!r}")
        if self in memo:
            existing = memo.get(self)
            print(f"  Already copied to {existing!r}")
            return existing
        print("  Memo dictionary:")
        if memo:
            for k, v in memo.items():
                print(f"    {k}: {v}")
        else:
            print("    (empty)")

        dup = Graph(copy.deepcopy(self.name, memo), [])
        print(f"  Copying to new object {dup}")
        memo[self] = dup

        for c in self.connections:
            dup.add_connection(copy.deepcopy(c, memo))
        return dup


def main():
    root = Graph("root", [])
    a = Graph("a", [root])
    b = Graph("b", [a, root])
    root.add_connection(a)
    root.add_connection(b)

    dup = copy.deepcopy(root)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Pprint}
\begin{lstlisting}[language=Python]
"""
Listing 2.77

The simplest way to use the module is through the pprint() function
"""
import pprint
from pprint_data import data


def main():
    print("PRINT:")
    print(data)
    print("PPRINT:")
    pprint.pprint(data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Pformat}
\begin{lstlisting}[language=Python]
"""
Listing 2.78

To format a data structure without writing it directly to a stream
(for example, for logging), use pformat() to build a string representation
"""
import logging
import pprint
from pprint_data import data


def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(levelname)-8s %(message)s"
    )
    logging.debug("Logging pformatted data")
    formatted = pprint.pformat(data)
    for line in formatted.splitlines():
        logging.debug(line.rstrip())


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Arbitrary Object}
\begin{lstlisting}[language=Python]
"""
Listing 2.79

The PrettyPrinter class used by pprint() can also work with custom
classes, if they define a __repr__() method
"""
import pprint


class node:

    def __init__(self, name, contents=[]):
        self.name = name
        self.contents = contents[:]

    def __repr__(self):
        return f"node({repr(self.name)}, {repr(self.contents)})"


def main():
    trees = [
        node("node-1"),
        node("node-2", [node("node-2-1")]),
        node("node-3", [node("node-3-1")])
    ]
    pprint.pprint(trees)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Recursion}
\begin{lstlisting}[language=Python]
"""
Listing 2.80

Recursive data structures are represented with a reference to the
original source of the data given in the format
    <Recrusion on typename with id=number>
"""
import pprint


def main():
    local_data = ["a", "b", 1, 2]
    local_data.append(local_data)

    print(f"id(local_data) => {id(local_data)}")
    pprint.pprint(local_data)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Depth}
\begin{lstlisting}[language=Python]
"""
Listing 2.81

For very deep data structures, it may not be desireable for the output
to include all of the details. The data may not be formatted properly,
the formatted text might be too large to manage, or some of the data
may be extraneous
"""
import pprint
from pprint_data import data


def main():
    pprint.pprint(data, depth=1)
    pprint.pprint(data, depth=2)
    pprint.pprint(data, depth=3)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Width}
\begin{lstlisting}[language=Python]
"""
Listing 2.82

The default output width for the formatted text is 80 columns. To adjust
that width, use the width argument to pprint()
"""
import pprint
from pprint_data import data


def main():
    for width in [80, 5]:
        print(f"WIDTH = {width}")
        pprint.pprint(data, width=width)
        print()


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Pprint Compact}
\begin{lstlisting}[language=Python]
"""
Listing 2.83

The compact flag tells pprint() to try to fit more data on each individual
line, rather than spreading complex data structures across lines
"""
import pprint
from pprint_data import data


def main():
    print("DEFAULT:")
    pprint.pprint(data, compact=False)
    print("\nCOMPACTS:")
    pprint.pprint(data, compact=True)


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Doc Module Array.Py}
\begin{lstlisting}[language=Python]
"""
TODO: Add array module documentation
"""
\end{lstlisting}
\section{Doc Module Bisect.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add bisect module documentation
"""
\end{lstlisting}
\section{Doc Module Collections.Py}
\begin{lstlisting}[language=Python]
"""
TODO: Add collections documentation
"""
\end{lstlisting}
\section{Doc Module Copy.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add copy module documentation
"""
\end{lstlisting}
\section{Doc Module Enum.Py}
\begin{lstlisting}[language=Python]
"""
TODO: Add enum documentation
"""
\end{lstlisting}
\section{Doc Module Heapq.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add heapq module documentation
"""
\end{lstlisting}
\section{Doc Module Pprint.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add pprint module documentation
"""
\end{lstlisting}
\section{Doc Module Queue.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add queue module documentation
"""
\end{lstlisting}
\section{Doc Module Struct.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add struct module documentation
"""
\end{lstlisting}
\section{Doc Module Weakref.Py}
\begin{lstlisting}[language=Python]
"""
TODO: add weakref module documentation
"""
\end{lstlisting}
\section{Heapq Heapdata.Py}
\begin{lstlisting}[language=Python]
"""
Listing 2.46

A heap is a tree-like data structure in which the child nodes have a sort-
order relationship with the parents. Binary heaps can be represented using
an array or list organised so that the children of element N are at
positions 2*N + 1 and 2*N + 2 (for zero-based indexes). This
layout makes it possible to rearrange heaps in place, so it is not
necessary to reallocate as much memory when adding or removing
items

A max-heap ensures that the parent is larger than or equal to both of
its children. A min-heap requires that the parent be less than or equal
to its children. Python's heapq module implement a min-heap
"""
data = [19, 9, 4, 10, 11]

\end{lstlisting}
\section{Heapq Showtree.Py}
\begin{lstlisting}[language=Python]
"""
Listing 2.47

The heap output is printed using heapq_showtree
"""
import math
import io


def show_tree(tree, total_width=36, fill=" "):
    """Pretty-print a tree"""
    output = io.StringIO()
    last_row = -1

    for i, n in enumerate(tree):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0
        if row != last_row:
            output.write("\n")
        columns = 2 ** row
        col_width = int(math.floor(total_width / columns))
        output.write(str(n).center(col_width, fill))
        last_row = row
    print(output.getvalue())
    print("-" * total_width)
    print()

\end{lstlisting}
\section{Pprint Data.Py}
\begin{lstlisting}[language=Python]
"""
Listing 2.76

The pprint module contains a "pretty printer" for producing aesthetically
pleasing views of data structures. The formatter produces representations
of data structures that can be parsed correctly by the interpreter,
and that are also easy for a human to read.

The output is kept on a single line, if possible, and indented when split
across multiple lines
"""
data = [
    (1, {"a": "A", "b": "B", "c": "C", "d": "D"}),
    (2, {"e": "E", "f": "F", "g": "G", "h": "H",
         "i": "I", "j": "J", "k": "K", "l": "L"}),
    (3, ["m", "n"]),
    (4, ["o", "p", "q"]),
    (5, ["r", "s", "t" "u", "v", "x", "y", "z"])
]

\end{lstlisting}
\chapter{Chapter03}
\section{Functools Partial}
\begin{lstlisting}[language=Python]
"""
Listing 3.1

The functools module provides tools for adapting or extending functions
and other callable objects, without completely rewriting them

The primary tool supplied by the functools module is the class partial
which can be used to "wrap" a callable object with default arguments.
The resulting object is itself callable and can be treated as though it
is the original function. It takes all of the same arguments as the
original, and can be invoked with extra positional or named arguments as
well. A partial can be used instead of a lambda to provide default
arguments to a function, while leaving some arguments unspecified.
"""
import functools


def myfunc(a, b=2):
    """Docstring for myfunc()."""
    print("  called myfunc with:", (a, b))


def show_details(name, f, is_partial=False):
    """Show details of a callable object"""
    print(f"{name}")
    print(f"  object:", f)
    if not is_partial:
        print("  __name__:", f.__name__)
    if is_partial:
        print("  func:", f.func)
        print("  args:", f.args)
        print("  keywords:", f.keywords)


def main():
    show_details("myfunc", myfunc)
    myfunc("a", 3)
    print()

    # Set a different value for "b", but require
    # the caller to provide "a"
    p1 = functools.partial(myfunc, b=4)
    show_details("partial with named default", p1, True)
    p1("passing a")
    p1("override b", b=5)
    print()

    # Set a different value for both "a" "b".
    p2 = functools.partial(myfunc, "default a", b=99)
    show_details("partial with defaults", p2, True)
    p2()
    p2(b="override b")
    print()

    print("Insufficient arguments:")
    p1()  # TypeError


if __name__ == "__main__":
    main()

\end{lstlisting}
\section{Functools Update Wrapper}
\begin{lstlisting}[language=Python]

\end{lstlisting}
\end{document}